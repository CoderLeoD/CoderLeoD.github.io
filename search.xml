<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于React的拖拽效果</title>
      <link href="/2023/12/26/ji-yu-react-de-tuo-zhuai-xiao-guo/"/>
      <url>/2023/12/26/ji-yu-react-de-tuo-zhuai-xiao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="基于-React-的拖拽效果-Demo"><a href="#基于-React-的拖拽效果-Demo" class="headerlink" title="基于 React 的拖拽效果 Demo"></a>基于 React 的拖拽效果 Demo</h1><p>一个基于 React 的拖拽功能实现的 Demo.</p><h2 id="两个关键点"><a href="#两个关键点" class="headerlink" title="两个关键点"></a>两个关键点</h2><p>1, draggable 属性</p><p>2, drag 事件</p><h3 id="draggable-属性"><a href="#draggable-属性" class="headerlink" title="draggable 属性"></a>draggable 属性</h3><p>img 标签默认是支持拖拽的, 当时其他 HTML 标签, 想要其拖动的话, 需要为其添加 draggable&#x3D;”true” 属性</p><h3 id="drag-事件"><a href="#drag-事件" class="headerlink" title="drag 事件"></a>drag 事件</h3><p>drag 相关的事件有: ondragstart、ondragend、ondragenter、ondragover、ondragleave、ondrop</p><p>一般情况下, 在实际使用时, 根据需求会有以下使用情况:</p><p>1, 被拖拽元素实现: ondragstart、ondragend</p><p>2, 被放置元素实现: ondragenter、ondragover、ondragleave、ondrop</p><p>注意: ondragover 的默认事件 Reset the current drag operation to “none”. 所以想让一个元素可放置，需要重写 ondragover, 使用 preventDefault() 阻止其默认行为.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">ondragover</span> = <span class="function"><span class="params">event</span> =&gt;</span> &#123; </span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般会在 ondrop 事件中确定最终行为的实现.</p><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>项目分为 todo-panel, todo-list, todo-item 三个组件</p><p>1, todo-panel 控制整个 demo 效果的布局和总逻辑的实施, 所有响应式的 state 都在该组件中实现.<br>总控室.<br>所有需要动态渲染的 state 都在当前组件中配置</p><p>2, todo-list 列表组件, 用于展示某种形态的列表<br>桥梁.<br>子组件(todo-item)的 drag 行为需要通过 todo-list 组件传递给父组件(todo-panel);<br>父组件(todo-panel)的 state 变化, 也会引起 todo-list 的动态渲染.</p><p>3, todo-item 本 demo 中最小的行动单元, 具体的某一个 todo行为 的 封装组件<br>也是 被拖拽 的元素(组件), 因此, 在其内部实现了 ondragstart 和 ondragend 两个方法</p><p><strong>注意: 当前 demo 只是一个本地的演示, 目的在于说明 drag 行为的实现需要配置的属性 以及 可能需要实现的事件, 在实际工作中可能还需要 ajax 请求的参与, 这里不再赘述.</strong></p><h1 id="项目源码地址"><a href="#项目源码地址" class="headerlink" title="项目源码地址"></a>项目源码地址</h1><p><a href="https://github.com/CoderLeoD/react-drag">源码地址传送门</a></p><h1 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h1><p><img src="https://raw.githubusercontent.com/CoderLeoD/react-drag/main/src/images/demo.png" class="lazyload placeholder" data-srcset="https://raw.githubusercontent.com/CoderLeoD/react-drag/main/src/images/demo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目截图"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> react-drag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>remote: Support for password authentication was removed on August 13, 2021.</title>
      <link href="/2023/12/19/remote-support-for-password-authentication-was-removed-on-august-13-2021/"/>
      <url>/2023/12/19/remote-support-for-password-authentication-was-removed-on-august-13-2021/</url>
      
        <content type="html"><![CDATA[<p>往 GitHub 上推送项目时，报如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remote: Support <span class="keyword">for</span> password authentication was removed on August 13, 2021.</span><br><span class="line"></span><br><span class="line">remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories<span class="comment">#cloning-with-https-urls for information on currently recommended modes of authentication.</span></span><br><span class="line"></span><br><span class="line">fatal: Authentication failed <span class="keyword">for</span> <span class="string">&#x27;https://github.com/XXXXXXX/&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>意思是：</strong>原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</p><p>也就是说，你需要使用 token 来代替密码了。</p><p><strong>token 在哪里生成呢？</strong></p><p>在github个人设置页面，找到Setting -&gt;选择开发者设置Developer setting -&gt; 选择个人访问令牌Personal access tokens，然后选中生成令牌Generate new token -&gt; 生成令牌Generate token</p><p>在上述位置根据提示选项，生成新的 token 之后，再次上传时，在 密码 位置输入上述 token 即可！</p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> GitHub 上传代码报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/19/hello-world/"/>
      <url>/2023/12/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac中nvm切换node版本失败</title>
      <link href="/2023/12/14/mac-zhong-nvm-qie-huan-node-ban-ben-shi-bai/"/>
      <url>/2023/12/14/mac-zhong-nvm-qie-huan-node-ban-ben-shi-bai/</url>
      
        <content type="html"><![CDATA[<p>Mac中使用 nvm 管理 node 版本，在使用指令：<code>nvm use XXX</code> 切换版本之后。</p><p>关闭终端，再次打开，输入 <code>node -v</code> 还是得到之前的 node 版本。</p><p>原因：<br><img src="/myImg/nvm/mac/env/changeerror1.png" class="lazyload placeholder" data-srcset="/myImg/nvm/mac/env/changeerror1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="切换失败原因"></p><p>在这里这个 default 中有个 node 的版本号，使用 <code>nvm use XXX</code> 时，没法修改这个版本号。</p><p>解决方案：</p><p>使用 <code>nvm alias default XXX</code> 指令设置默认 node 版本。</p><p>目前看来，Mac 中通过 nvm 长期有效的切换 node 版本可能需要两个指令：</p><ol><li><code>nvm use XXX</code>（只对当前终端窗口有效）</li><li><code>nvm alias default XXX</code>（长期有效，即使关闭终端窗口后，再打开一个新的终端窗口）</li></ol><p>暂时没有好的方式通过执行一条指令来实现。</p><p>欢迎在评论区留言好的处理方案！</p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac 配置 </tag>
            
            <tag> nvm </tag>
            
            <tag> node版本切换失败 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装nvm</title>
      <link href="/2023/12/11/mac-an-zhuang-nvm/"/>
      <url>/2023/12/11/mac-an-zhuang-nvm/</url>
      
        <content type="html"><![CDATA[<h2 id="一，nvm简介"><a href="#一，nvm简介" class="headerlink" title="一，nvm简介"></a>一，nvm简介</h2><p>nvm全称 Node Version Manager ，意思为node版本控制；它是一个命令行应用，可以快速地更新、安装、使用、卸载本机的全局 node.js 版本。他可以在同一台电脑上进行多个node版本之间的切换，而这正是nvm的价值所在。</p><p>当你同时进行两个或多个node项目开发，并且这些项目的node版本不一样时，nvm可以很好的帮你管理pc上的node版本切换 </p><h2 id="二，卸载Mac中现在已安装到全局的-node-npm"><a href="#二，卸载Mac中现在已安装到全局的-node-npm" class="headerlink" title="二，卸载Mac中现在已安装到全局的 node&#x2F;npm"></a>二，卸载Mac中现在已安装到全局的 node&#x2F;npm</h2><p>安装 nvm 之前最好先删除下已安装的 node 和全局 node 模块，避免引起冲突。</p><p>根据需求，输入以下终端指令。</p><p>卸载从官网下载的pkg文件的nodejs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /usr/local/&#123;bin/&#123;node,npm&#125;,lib/node_modules/npm,lib/node,share/man/*/node.*&#125;</span><br></pre></td></tr></table></figure><p>卸载从homebrew 安装的node：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall node</span><br></pre></td></tr></table></figure><p>之后在终端输入 <code>node -v &amp;&amp; npm -v</code> 验证是否卸载完成。</p><p>以上指令之后，node就被卸载完毕了，想要再更更详细的删除可参考：<a href="https://blog.csdn.net/huangpb123/article/details/120248002">Mac彻底卸载node_mac 卸载node_huangpb0624的博客-CSDN博客</a></p><h2 id="三，安装-nvm"><a href="#三，安装-nvm" class="headerlink" title="三，安装 nvm"></a>三，安装 nvm</h2><p>打开终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/nvm-sh/nvm.git</span><br></pre></td></tr></table></figure><p>再进入 nvm目录中执行install.sh 等待执行完成，终端依次输出以下指令：<br>输入：<code>cd nvm</code> （进入nvm目录）<br>再输入：<code>./install.sh</code>  （等待执行成功）<br><img src="/myImg/nvm/mac/env/anzhuang1.png" class="lazyload placeholder" data-srcset="/myImg/nvm/mac/env/anzhuang1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="安装 nvm"></p><p>在 <code>./install.sh</code> 指令运行结束之后，终端就会告诉你在 .bash_profile 中配置了相关环境（如上图），也就意味着到这里，nvm 已经安装完成，如果你想手动再配置一次，可以执行下述步骤四, 不想再手动配置一次的话, 就直接 步骤五。</p><h2 id="四，配置nvm环境"><a href="#四，配置nvm环境" class="headerlink" title="四，配置nvm环境"></a>四，配置nvm环境</h2><p>在终端输入：<code>vi ~/.bash_profile</code>进入bash中</p><p>将以下代码输入到bash中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="variable">$HOME</span>/.nvm&quot;</span></span><br><span class="line"></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span>  <span class="comment"># This loads nvm</span></span><br><span class="line"></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/bash_completion&quot;</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure><p>最后返回终端输入：<code>source ~/.bash_profile</code> 进行文件更新。</p><h2 id="五，验证是否安装成功"><a href="#五，验证是否安装成功" class="headerlink" title="五，验证是否安装成功"></a>五，验证是否安装成功</h2><p>执行 <code>nvm --version</code> 检测是否安装成功<br><img src="/myImg/nvm/mac/env/anzhuang2.png" class="lazyload placeholder" data-srcset="/myImg/nvm/mac/env/anzhuang2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="nvm 版本信息"></p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
            <tag> Mac配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac进入hosts</title>
      <link href="/2023/12/11/mac-jin-ru-hosts/"/>
      <url>/2023/12/11/mac-jin-ru-hosts/</url>
      
        <content type="html"><![CDATA[<p>前往文件夹输入以下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/private/etc/hosts</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac配置 </tag>
            
            <tag> Mac </tag>
            
            <tag> Mac进入hosts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Expo创建的ReactNative项目Android模拟器启动失败</title>
      <link href="/2023/11/13/expo-chuang-jian-de-reactnative-xiang-mu-android-mo-ni-qi-qi-dong-shi-bai/"/>
      <url>/2023/11/13/expo-chuang-jian-de-reactnative-xiang-mu-android-mo-ni-qi-qi-dong-shi-bai/</url>
      
        <content type="html"><![CDATA[<ul><li>省流：失败的尝试！！！</li></ul><p>Error: adb: failed to install C:\Users\Administrator.expo\android-apk-cache\Exponent-2.29.8.apk: Failure [INSTALL_FAILED_CONTAINER_ERROR: Failed to extract native libraries, res&#x3D;-18]</p><p>使用 Expo 搭建的 React Natvie 项目在执行了 npm start 之后， 启动成功， 有个二维码可以扫，局域网运行没有问题.</p><p>可是, 还是想要在 Android 模拟器上运行。</p><p>于是，输入指令 a，来在 Android 模拟器上运行。</p><p>模拟器可以正常启动，但是报错：Error: adb: failed to install C:\Users\Administrator.expo\android-apk-cache\Exponent-2.29.8.apk: Failure [INSTALL_FAILED_CONTAINER_ERROR: Failed to extract native libraries, res&#x3D;-18]</p><p>大量搜索后无果，Google 之后，有了如下解决方案：<br><img src="/myImg/reactnative/env/error-android-1.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-android-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="GitHub 解决方案"></p><p>按照以上方案执行后，再次输入 a 启动，不起作用！！！</p>]]></content>
      
      
      <categories>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Expo </tag>
            
            <tag> React Native </tag>
            
            <tag> Android模拟器启动失败 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置或取消git全局代理</title>
      <link href="/2023/11/02/she-zhi-huo-qu-xiao-git-quan-ju-dai-li/"/>
      <url>/2023/11/02/she-zhi-huo-qu-xiao-git-quan-ju-dai-li/</url>
      
        <content type="html"><![CDATA[<p>取消全局代理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line"></span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p>然后对应的代理端口为【具体的代理端口得依赖于本机代理软件】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> git 全局代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac中ReactNative环境搭建</title>
      <link href="/2023/11/02/mac-zhong-reactnative-huan-jing-da-jian/"/>
      <url>/2023/11/02/mac-zhong-reactnative-huan-jing-da-jian/</url>
      
        <content type="html"><![CDATA[<ul><li>省流：失败！！！<br><strong>建议使用简易沙盒环境搭建项目, 比较丝滑</strong></li></ul><p><strong>万马奔腾！！！</strong></p><h1 id="Mac-版"><a href="#Mac-版" class="headerlink" title="Mac 版"></a>Mac 版</h1><p>根据官网步骤进行，<strong>V 0.72</strong></p><ul><li>注：在开始之前，我删除了电脑中已有 Homebrew ，重新安装最新版的 Homebrew。过程中使用有科学上网工具。</li></ul><p>关于 Homebrew 的安装问题，可以<a href="https://coderleod.github.io/2023/10/30/homebrew-an-zhuang-wen-ti-zong-jie/">参考这篇博客</a>。</p><h3 id="1，安装-node"><a href="#1，安装-node" class="headerlink" title="1，安装 node"></a>1，安装 node</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node@16</span><br></pre></td></tr></table></figure><p>下载到某个阶段，就进行不下去，停止后，耐着性子，继续执行上述指令，在执行失败了 N 次以后，<em><strong>直接下载了 Nodejs 官网的 pkg 进行安装。</strong></em></p><h3 id="2，安装-watchman"><a href="#2，安装-watchman" class="headerlink" title="2，安装 watchman"></a>2，安装 watchman</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install watchman</span><br></pre></td></tr></table></figure><p>跟 1中 指令一样，安装到某一个耗时较长的框架就会断（失败），那就反复执行这个指令，直到下载成功。</p><p>我大概反复执行了 4次 该指令。</p><p>没有切换淘宝源。</p><h3 id="3，配置-yarn"><a href="#3，配置-yarn" class="headerlink" title="3，配置 yarn"></a>3，配置 yarn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><p>需要管理员权限，又执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g yarn</span><br></pre></td></tr></table></figure><h3 id="4，Xcode-安装"><a href="#4，Xcode-安装" class="headerlink" title="4，Xcode 安装"></a>4，Xcode 安装</h3><p>安装完成之后，配置模拟器。</p><p>关于 Xcode 的安装这里不再赘述，有不懂的自行搜索安装配置。</p><h3 id="5，CocoaPods-安装"><a href="#5，CocoaPods-安装" class="headerlink" title="5，CocoaPods 安装"></a>5，CocoaPods 安装</h3><p>CocoaPods 被誉为 iOS 的 npm。</p><p>安装指令，以下二选一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">brew install cocoapods</span><br></pre></td></tr></table></figure><p>我最开始使用了 brew 的方式来安装，毕竟刚刚安装完 brew，想继续使用它。</p><p>过程中依然会遇到某一个库安装比较慢 和 卡断 的问题，我 brew 安装 cocoapods 指令执行了 三四次才安装OK。</p><h3 id="6，react-native-cli-卸载"><a href="#6，react-native-cli-卸载" class="headerlink" title="6，react-native-cli 卸载"></a>6，react-native-cli 卸载</h3><p>我之前安装过 react-native-cli，所以先执行卸载的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g react-native-cli @react-native-community/cli</span><br></pre></td></tr></table></figure><h3 id="7，创建-ReactNative-项目"><a href="#7，创建-ReactNative-项目" class="headerlink" title="7，创建 ReactNative 项目"></a>7，创建 ReactNative 项目</h3><p>在想要创建 ReactNative 项目的文件夹下，执行以下指令来创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx react-native@latest init AwesomeProject</span><br></pre></td></tr></table></figure><p>可是，还是失败了！项目创建失败！<br><img src="/myImg/reactnative/env/error-1.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目创建失败"></p><p>结果如上图！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">✖ Installing Ruby Gems</span><br><span class="line"></span><br><span class="line">error Ignoring ffi-1.15.1 because its extensions are not built. Try: gem pristine ffi --version 1.15.1</span><br><span class="line"></span><br><span class="line">✖ Installing Ruby Gems</span><br><span class="line"></span><br><span class="line">error Looks like your iOS environment is not properly <span class="built_in">set</span>. Please go to https://reactnative.dev/docs/environment-setup?os=macos&amp;platform=android and follow the React Native CLI QuickStart guide <span class="keyword">for</span> macOS and iOS.</span><br></pre></td></tr></table></figure><h2 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h2><h3 id="1，CocoaPods-问题？"><a href="#1，CocoaPods-问题？" class="headerlink" title="1，CocoaPods 问题？"></a>1，CocoaPods 问题？</h3><p>瞎猜的，不过在排查时，有重大发现！！！</p><p><em><strong>Mac 自带有 ruby 环境</strong></em>，而 CocoaPods 和 Homebrew 在安装和配置时都有关于 ruby 环境的更新和使用。并且，由于路径的问题，我们一直使用的都是 Mac 自带的 ruby，所以在<a href="https://mac.install.guide/ruby/13.html">这个地址</a>，发现了修改 ruby 环境地址的方法。</p><p>我这里也记录一份，修改 ruby 环境路径的具体修改步骤如下：</p><h4 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h4><p>依次输入如下终端指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ruby</span><br><span class="line"></span><br><span class="line">ruby -v</span><br></pre></td></tr></table></figure><p>得到如下结果，说明你的电脑 ruby 环境 Mac 默认的 ruby 环境<br><img src="/myImg/reactnative/env/ruby-1.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/ruby-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Mac 默认的 ruby 环境"></p><h4 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h4><p>终端执行以下指令，或者直接找到文件进行编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -e ~/.zshrc</span><br></pre></td></tr></table></figure><p>如果告诉你没有找到 .zshrc 文件，<a href="https://coderleod.github.io/2023/11/01/mac-chuang-jian-bing-shi-yong-zshrc-wen-jian/">请移步这里创建并使用 .zshrc 文件。</a></p><h4 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h4><p>在 .zshrc 文件中输入以下内容</p><p>Inter 芯片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/usr/local/opt/ruby/bin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> PATH=/usr/local/opt/ruby/bin:<span class="variable">$PATH</span></span><br><span class="line">  <span class="built_in">export</span> PATH=`gem environment gemdir`/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>M系列芯片：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/opt/homebrew/opt/ruby/bin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> PATH=/opt/homebrew/opt/ruby/bin:<span class="variable">$PATH</span></span><br><span class="line">  <span class="built_in">export</span> PATH=`gem environment gemdir`/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h4><p>保存并关闭 .zshrc 文件。</p><p>关闭终端窗口，以确认修改。</p><h4 id="步骤五："><a href="#步骤五：" class="headerlink" title="步骤五："></a>步骤五：</h4><p>再次输入 ruby -v 指令，获取到最新的 ruby 版本（不是步骤一中的版本，就代表路径修改完毕了，没必要再执行 which ruby 指令了）。</p><p>执行完以上步骤之后，再次在目标文件夹中执行 npx react-native@latest init AwesomeProject 指令，尝试创建 React Native 项目。</p><p><img src="/myImg/reactnative/env/error-2.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目创建失败"></p><p>又报错了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">✔ Processing template</span><br><span class="line"></span><br><span class="line">✖ Installing Ruby Gems</span><br><span class="line"></span><br><span class="line">error /Library/Ruby/Site/2.6.0/rubygems.rb:264:<span class="keyword">in</span> `find_spec_for_exe<span class="string">&#x27;: can&#x27;</span>t find gem bundler (&gt;= 0.a) with executable bundle (Gem::GemNotFoundException)</span><br><span class="line"></span><br><span class="line">from /Library/Ruby/Site/2.6.0/rubygems.rb:283:<span class="keyword">in</span> `activate_bin_path<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from /usr/bin/bundle:23:in `&lt;main&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">✖ Installing Ruby Gems</span><br><span class="line"></span><br><span class="line">error Looks like your iOS environment is not properly <span class="built_in">set</span>. Please go to https://reactnative.dev/docs/environment-setup?os=macos&amp;platform=android and follow the React Native CLI QuickStart guide <span class="keyword">for</span> macOS and iOS.</span><br></pre></td></tr></table></figure><p>这不还是 Ruby 的问题吗？难道没有修改成功？</p><p>ruby -v 发现确实 ruby 路径又出问题了。</p><p>再次按照上述博客修改 ruby 默认路径。</p><p>之后再次执行 npx react-native@latest init AwesomeProject 指令创建项目。</p><p>再次失败。报错如下：<br><img src="/myImg/reactnative/env/error-3.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目创建失败"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">✔ Installing Ruby Gems</span><br><span class="line"></span><br><span class="line">⠴ Updating CocoaPods repositories (this may take a few minutes)  fatal: unable to access <span class="string">&#x27;https://github.com/CocoaPods/Specs.git/&#x27;</span>: Recv failure: Operation timed out</span><br><span class="line"></span><br><span class="line">✖ Updating CocoaPods repositories (this may take a few minutes)</span><br><span class="line"></span><br><span class="line">✖ Updating CocoaPods repositories (this may take a few minutes)</span><br><span class="line"></span><br><span class="line">error Failed to update CocoaPods repositories <span class="keyword">for</span> iOS project.</span><br><span class="line"></span><br><span class="line">Please try again manually: <span class="string">&quot;pod repo update&quot;</span>.</span><br><span class="line"></span><br><span class="line">CocoaPods documentation: https://cocoapods.org/.</span><br><span class="line"></span><br><span class="line">info Run CLI with --verbose flag <span class="keyword">for</span> more details.</span><br></pre></td></tr></table></figure><p>随后，执行 pod repo update 失败。</p><p><img src="/myImg/reactnative/env/error-4.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目创建失败"></p><p>然后执行：sudo pod repo update –verbose</p><p>出错了，我想当然的加了 sudo，执行后 报错，不能使用 sudo，但是我没注意。</p><p><img src="/myImg/reactnative/env/error-5.png" class="lazyload placeholder" data-srcset="/myImg/reactnative/env/error-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="项目创建失败"></p><p>然后开始搜索：[!] CocoaPods was not able to update the <code>cocoapods</code> repo. If this is an unexpected issue and persists you can inspect it running <code>pod repo update --verbose</code></p><p>找到一篇博客，说是 执行 pod repo list 然后发现有三个 repo 源，然后执行</p><p>pod repo remove XXX 来逐个卸载感觉不对的 源。过程中，可能卸载错了源，导致后面卸载重装 cocoapods。</p><p>然后就执行 pod repo update 指令。报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] CocoaPods was not able to update the `cocoapods` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`</span><br></pre></td></tr></table></figure><p>执行 pod update 企图再次更新。报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[!] No `Podfile<span class="string">&#x27; found in the project directory.</span></span><br></pre></td></tr></table></figure><p>算了，卸载吧！这是乱搞的下场，不再乱搞了，卸载 cocoapods，然后重新来过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall cocoapods</span><br></pre></td></tr></table></figure><p>然后：sudo gem install cocoapods，换一种安装 cocoapods 的方式。安装成功。</p><p>看到终端告诉我：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A new release of RubyGems is available: 3.4.10 → 3.4.21!</span><br><span class="line"></span><br><span class="line">Run `gem update --system 3.4.21` to update your installation.</span><br></pre></td></tr></table></figure><p>那就执行指令：gem update –system 3.4.21</p><p>随后：ruby -v</p><p>得到结果：ruby 3.2.2 (2023-03-30 revision e51014f9c0) [x86_64-darwin21]</p><p>（好像跟之前的ruby版本一样，不纠结了，其实是更新失败了，但感觉这个 3.2.2 也可以了）</p><p>折腾了半天。</p><p>执行：pod setup 指令，得到结果：Setup completed。</p><p>React Native 环境配置中，安装完 cocoapods 之后，没有要求执行 pod setup 指令，之前在搜索卸载安装 cocoapods 时，发现了这个指令，好像回想起来 cocoapods 需要 setup 的吧。索性就执行下吧。</p><p>然后 输入 pod –version，得到当前版本号 1.14.2 。之前是 1.13.0 。这也算是这段折腾的收货吧。</p><p>pod repo list 输出的 repo 源只有一个了。</p><p>执行：pod repo update 指令。想着创建 React Native 项目之前，再执行下这个指令吧，省得待会儿创建项目时再报 repo 的问题。</p><p>还是报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Updating spec repo `cocoapods`</span><br><span class="line"></span><br><span class="line">  $ /usr/bin/git -C /Users/xuedongli/.cocoapods/repos/cocoapods fetch origin --progress</span><br><span class="line"></span><br><span class="line">  fatal: unable to access <span class="string">&#x27;https://github.com/CocoaPods/Specs.git/&#x27;</span>: Failure when receiving data from the peer</span><br><span class="line"></span><br><span class="line">[!] CocoaPods was not able to update the `cocoapods` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`</span><br></pre></td></tr></table></figure><p>再执行下：pod repo update –verbose 吧。……</p><p>更新成功了！。。。。。。</p><p>我上面折腾了半天，是不是我想当然的加了 sudo 惹的祸。。。。。。哎！</p><p>继续执行：npx react-native@latest init AwesomeProject 指令创建项目吧！</p><p>关于 React Native 的原生安装方式的探索到此结束吧, 有时间了再来摸索！</p><p>接下来就使用 简易沙盒 环境来了创建项目！</p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> React Native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React Native </tag>
            
            <tag> Mac配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac创建并使用.zshrc文件</title>
      <link href="/2023/11/01/mac-chuang-jian-bing-shi-yong-zshrc-wen-jian/"/>
      <url>/2023/11/01/mac-chuang-jian-bing-shi-yong-zshrc-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>​<br>1，打开终端输入指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> .zshrc</span><br></pre></td></tr></table></figure><p>2，你可能希望将 .bash_profile 文件中的内容复制到 .zshrc 文件中，那建议复制过来。</p><p>3，使用 .zshrc 文件</p><p>执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .zshrc</span><br></pre></td></tr></table></figure><ul><li>注：以后希望使用 .bash_profile 了，再执行 source .bash_profile 吧。</li></ul><p>完！</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Mac配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac配置 </tag>
            
            <tag> .zshrc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew安装问题总结</title>
      <link href="/2023/10/30/homebrew-an-zhuang-wen-ti-zong-jie/"/>
      <url>/2023/10/30/homebrew-an-zhuang-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>​<br>安装 Homebrew 执行指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>之后，报错，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (7) Failed to connect to raw.githubusercontent.com port 443 after 27 ms: Couldn<span class="string">&#x27;t connect to server</span></span><br></pre></td></tr></table></figure><p>意思是，连接不到 raw.githubusercontent.com 这个地址执行操作了。</p><p>网上查了些方案，说是在 hosts 文件中配置 raw.githubusercontent.com 地址的就可以了。</p><p>但是，配置好之后，再次执行，又报错了，内容是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (35) Recv failure: Connection reset by peer</span><br></pre></td></tr></table></figure><p>其实啊，在国内能进入 Homebrew 官网的，就非等闲之辈！（八成科学上网了）</p><p>既然你都科学上网了，直接读一读 GitHub 上 Homebrew 的md文档，人家直接告诉你，macOS 系统，可以直接下载 pkg 来安装！！！</p><p><strong>那就直接下载 pkg 来安装吧！</strong><br>​</p>]]></content>
      
      
      <categories>
          
          <category> Homebrew </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Router刷新当前页面</title>
      <link href="/2023/10/20/vue-router-shua-xin-dang-qian-ye-mian/"/>
      <url>/2023/10/20/vue-router-shua-xin-dang-qian-ye-mian/</url>
      
        <content type="html"><![CDATA[<p>Vue项目, 在实际工作中, 有些时候需要在 加载完某些数据之后对当前页面进行刷新, 以期 onMounted 等生命周期函数, 或者 数据重新加载. <strong>总之是期望页面可以重新加载一次.</strong></p><p>目前总结有三种途径可实现以上需求:</p><h2 id="一-reload-直接刷新页面"><a href="#一-reload-直接刷新页面" class="headerlink" title="一, reload 直接刷新页面"></a>一, reload 直接刷新页面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">$router.<span class="title function_">go</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>相当于按了 F5, 因此缺点也很明显, 体验感不佳, 因为要加载所有页面资源相对较慢, 比较耗时.</p><h2 id="二-Vue-Router-刷新当前页面"><a href="#二-Vue-Router-刷新当前页面" class="headerlink" title="二, Vue Router 刷新当前页面"></a>二, Vue Router 刷新当前页面</h2><p>这个时候, 我们通过 $router.push 一个 refresh 路由的形式实现, 具体步骤如下:</p><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一:"></a>步骤一:</h3><p>新建一个 vue 文件, 文件中代码如下 ( 仅需要如下代码即可 ) :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> &gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      vm.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="keyword">from</span>.<span class="property">fullPath</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二:"></a>步骤二:</h3><p>在你的路由文件中, 配置上述文件路由, 示例代码:</p><p>routes 数组中直接添加就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/refresh&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;refresh&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;步骤一中创建文件的路径&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三:"></a>步骤三:</h3><p>在目标位置, 使用 $router.push 上述路由即可, 示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$router.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;refresh&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上三步, 结束!</p><h2 id="三-依赖注入方式实现"><a href="#三-依赖注入方式实现" class="headerlink" title="三, 依赖注入方式实现"></a>三, 依赖注入方式实现</h2><p>即, provide&#x2F;inject<br><strong>中心思想:</strong> 通过 v-if 来切换 router-view 的 显示&#x2F;隐藏 从而实现重新加载组件的目的. 步骤如下.</p><h3 id="步骤一-1"><a href="#步骤一-1" class="headerlink" title="步骤一:"></a>步骤一:</h3><p>修改 路由出口文件 ( 我测试时是在 App.vue 文件中加的 &lt;router-view &#x2F;&gt; ), 通过 provide 提供一个刷新方法给后代组件.</p><p>注意: 我的Demo中没有测试路由嵌套的场景, 如果你是路由嵌套, 只想刷新嵌套的子路由, 那在这一步修改的就应该是 子路由 出口文件.</p><p>核心代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- &lt;router-view&gt;&lt;/router-view&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">&quot;isRefreshFlag&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; ref, nextTick, provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> isRefreshFlag = <span class="title function_">ref</span>(<span class="literal">true</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">reloadPage</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  isRefreshFlag.<span class="property">value</span> = <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    isRefreshFlag.<span class="property">value</span> = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">provide</span>(<span class="string">&quot;reloadPage&quot;</span>, reloadPage)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="步骤二-1"><a href="#步骤二-1" class="headerlink" title="步骤二:"></a>步骤二:</h3><p>在目标组件的目标位置, 通过 inject 调用步骤一中的 reloadPage() 方法. 示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;refreshPage&quot;</span>&gt;</span>刷新页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> reloadPage = <span class="title function_">inject</span>(<span class="string">&quot;reloadPage&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">function</span> <span class="title function_">refreshPage</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">reloadPage</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>以上两步, 结束!</p><p>以上三种方式, 亲测有效, 不过是 Vue 3 的代码风格, Vue 2 请自行转换.</p><p>欢迎留言扩充新方法!</p>]]></content>
      
      
      <categories>
          
          <category> Vue-Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue-Router </tag>
            
            <tag> Vue </tag>
            
            <tag> Vue-Router刷新当前页面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac允许任何来源APP安装指令</title>
      <link href="/2023/03/30/mac-yun-xu-ren-he-lai-yuan-app-an-zhuang-zhi-ling/"/>
      <url>/2023/03/30/mac-yun-xu-ren-he-lai-yuan-app-an-zhuang-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>终端指令：sudo spctl –master-disable</p>]]></content>
      
      
      <categories>
          
          <category> Mac配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac配置 </tag>
            
            <tag> 允许任何来源APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nvm安装node</title>
      <link href="/2022/10/09/nvm-an-zhuang-node/"/>
      <url>/2022/10/09/nvm-an-zhuang-node/</url>
      
        <content type="html"><![CDATA[<p>使用nvm安装node常用指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 查看nvm版本</span><br><span class="line">nvm -v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 下载指定版本 nvm install latest安装最新版本</span><br><span class="line">nvm install 10.12.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 使用指定版本</span><br><span class="line">nvm use 10.12.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查看已经安装的nodejs版本</span><br><span class="line">nvm <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 查看nodejs版本</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><p>npm镜像替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//使用淘宝镜像cnmp替代npm</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//验证cnpm是否可用</span><br><span class="line">cnpm config get registry</span><br></pre></td></tr></table></figure><p>​<br>关于 npm 镜像的问题, 请参考更为详细的博客: <a href="https://coderleod.github.io/2021/06/08/npm-yu-cnpm-xiang-hu-qie-huan/">npm 与 cnpm 相互转换</a></p>]]></content>
      
      
      <categories>
          
          <category> nvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nvm </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHubDesktop通过ssh连接Github</title>
      <link href="/2022/08/11/githubdesktop-tong-guo-ssh-lian-jie-github/"/>
      <url>/2022/08/11/githubdesktop-tong-guo-ssh-lian-jie-github/</url>
      
        <content type="html"><![CDATA[<p>首先，通过 ssh 连接的好处在于不必每次都要验证GitHub的账号密码，减少了一些繁琐的操作，同时可以提高 pull&#x2F;push 的效率，特别是在网络比较差劲，无法通过 http 或 https 有效连接到GitHub时，ssh 就是一个不错的选择。</p><p>言归正传</p><h2 id="一，生成-ssh"><a href="#一，生成-ssh" class="headerlink" title="一，生成 ssh"></a>一，生成 ssh</h2><p>打开cmd，键入以下指令，会在指定目录下生成 .ssh文件夹（.开头的隐藏文件怎么查看，请自行查找方法）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xx.com&quot;</span></span><br></pre></td></tr></table></figure><p>回车之后，一般会在 C:\Users\用户名.ssh 位置生成一个名为 .ssh 的文件夹。</p><p>该文件中的 id_rsa.pub 文件中存放的就是公钥。</p><p>打开该文件（可通过记事本方式打开），复制出公钥。</p><h2 id="二，进入GitHub官网，设置你的公钥。"><a href="#二，进入GitHub官网，设置你的公钥。" class="headerlink" title="二，进入GitHub官网，设置你的公钥。"></a>二，进入GitHub官网，设置你的公钥。</h2><p>参考如下截图：<br><img src="/myImg/github/settings/ssh1.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设置公钥1"><br><img src="/myImg/github/settings/ssh2.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设置公钥2"><br><img src="/myImg/github/settings/ssh3.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设置公钥3"><br><img src="/myImg/github/settings/ssh4.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="设置公钥4"></p><p>Title：自己起一个有高分辨率的名字。</p><p>Key：就是你刚刚复制的 <strong>id_rsa.pub</strong> 文件中的内容。</p><p>配置好之后，Github 远程仓库，就可以和你的电脑通过 ssh 进行连接了。接下来，需要在 GitHubDesktop 软件中配置来使用 ssh。</p><h2 id="三，GitHubDesktop配置。"><a href="#三，GitHubDesktop配置。" class="headerlink" title="三，GitHubDesktop配置。"></a>三，GitHubDesktop配置。</h2><p>还是读图：<br><img src="/myImg/github/settings/ssh5.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="GitHubDesktop配置-1"><br><img src="/myImg/github/settings/ssh6.png" class="lazyload placeholder" data-srcset="/myImg/github/settings/ssh6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="GitHubDesktop配置-2"></p><p>在 Remote 中将 原来的 https:xxx.git 替换为这里的 git@ xxxxx.git 然后 save 就可以了。</p><p>接下来就可以愉快的开始 pull&#x2F;push 了。 </p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> GitHubDesktop </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数组遍历方法汇总</title>
      <link href="/2022/07/31/js-shu-zu-bian-li-fang-fa-hui-zong/"/>
      <url>/2022/07/31/js-shu-zu-bian-li-fang-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="数组遍历方法汇总"><a href="#数组遍历方法汇总" class="headerlink" title="数组遍历方法汇总"></a>数组遍历方法汇总</h1><h2 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1, for循环"></a>1, for循环</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.0<br><strong>兼容性:</strong> 无</p><h2 id="2-map"><a href="#2-map" class="headerlink" title="2, map()"></a>2, map()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.6<br><strong>兼容性:</strong> IE 9+, Firefox 1.5<br><strong>作用:</strong> 返回一个新数组, 数组中的元素为原始数组元素调用函数处理后的值<br><strong>语法:</strong> array.map(参数一,参数二)</p><ul><li>参数一: function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: thisValue<ul><li>可选值, 设置参数一中 this 所代表的对象. 如果不写 或 传入null、undefined, 则参数一中this为全局对象(window)</li></ul></li><li>返回值: 返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/map-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/map-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="map-示例"><br><img src="/myImg/javascript/array/bianli/map-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/map-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="map-结果"></p><p><strong>注: map() 方法不会修改原数组</strong></p><h2 id="3-filter"><a href="#3-filter" class="headerlink" title="3, filter()"></a>3, filter()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.6<br><strong>兼容性:</strong> IE 9+, Firefox 1.5<br><strong>作用:</strong> 创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br><strong>语法:</strong> array.filter(参数一,参数二)</p><ul><li>参数一: function(currentValue,index,arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr, 当前数组, 可选</li></ul></li><li>参数二: thisValue<ul><li>可选值, 设置参数一中 this 所代表的对象. 如果不写 或 传入null、undefined, 则参数一中this为全局对象(window)</li></ul></li><li>返回值: 经 参数一 函数返回值 条件筛选过之后的新数组</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/filter-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/filter-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="filter-示例"><br><img src="/myImg/javascript/array/bianli/filter-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/filter-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="filter-结果"></p><p><strong>注: filter() 方法不会修改原数组</strong></p><h2 id="4-every"><a href="#4-every" class="headerlink" title="4, every()"></a>4, every()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.6<br><strong>兼容性:</strong> IE 9+, Firefox 1.5<br><strong>作用:</strong> 用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p><ul><li>注意: 一旦检测为 false, 将不再继续检测数组中的其他值<br><strong>语法:</strong> array.every(参数一, 参数二)</li><li>参数一: function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: thisValue<ul><li>可选值, 设置参数一中 this 所代表的对象. 如果不写 或 传入null、undefined, 则参数一中this为全局对象(window)</li></ul></li><li>返回值: 布尔值. 如果所有元素都通过检测返回 true，否则返回 false。</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/every-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/every-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="every-示例"><br><img src="/myImg/javascript/array/bianli/every-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/every-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="every-结果"></p><h2 id="5-some"><a href="#5-some" class="headerlink" title="5, some()"></a>5, some()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.6<br><strong>兼容性:</strong> IE 9+, Firefox 1.5<br><strong>作用:</strong> 用于检测数组中是否有满足指定条件（函数提供）的元素。</p><ul><li>注意: 一旦检测为 true, 将不再继续检测数组中的其他值<br><strong>语法:</strong> array.some(参数一, 参数二)</li><li>参数一: function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: thisValue<ul><li>可选值, 设置参数一中 this 所代表的对象. 如果不写 或 传入null、undefined, 则参数一中this为全局对象(window)</li></ul></li><li>返回值: 布尔值。如果数组中有元素满足条件返回 true，否则返回 false。</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/some-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/some-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="some-示例"><br><img src="/myImg/javascript/array/bianli/some-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/some-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="some-结果"></p><h2 id="6-forEach"><a href="#6-forEach" class="headerlink" title="6, forEach()"></a>6, forEach()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 3<br><strong>兼容性:</strong> IE 9+, Firefox 1.5<br><strong>作用:</strong> 用于调用数组的每个元素，并将元素传递给回调函数。<br><strong>语法:</strong> array.forEach(参数一, 参数二)</p><ul><li>参数一: function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前值下标, 可选</li></ul></li><li>参数二: thisValue<ul><li>可选值, 设置参数一中 this 所代表的对象. 如果不写 或 传入null、undefined, 则参数一中this为全局对象(window)</li></ul></li><li>返回值: undefined(无返回值)</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/forEach-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/forEach-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="forEach-示例"><br><img src="/myImg/javascript/array/bianli/forEach-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/forEach-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="forEach-结果"></p><p><strong>注: forEach() 方法不会修改原数组</strong></p><h2 id="7-reduce"><a href="#7-reduce" class="headerlink" title="7, reduce()"></a>7, reduce()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 3<br><strong>兼容性:</strong> IE 9+, Firefox 3.0, Safari 4.0, Opera 10.5<br><strong>作用:</strong> 计算数组元素相加后的和<br><strong>语法:</strong> array.reduce(参数一, 参数二)</p><ul><li>参数一: function(total, currentValue, currentIndex, arr)<ul><li>total: 初始值 或者 数组中的第一个值 或者 前n项和, 必选</li><li>currentValue: 当前值, 必选</li><li>currentIndex: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: initialValue</li><li>初始值, 传递给回调函数(参数一)的初始值, 可选值</li><li>返回值: 计算后的结果</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/reduce-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/reduce-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="reduce-示例"><br><img src="/myImg/javascript/array/bianli/reduce-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/reduce-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="reduce-结果"></p><h2 id="8-for…in"><a href="#8-for…in" class="headerlink" title="8, for…in"></a>8, for…in</h2><p><strong>JavaScript 版本:</strong> ECMAScript 1.0<br><strong>兼容性:</strong> 无<br><strong>作用:</strong> 用于循环对象属性(也可以用于循环数组)<br><strong>语法:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>variable: 必选, 对象的key值(数组的下标)</li><li>object: 必选, 要遍历的对象(数组)</li><li>statement: 执行语句</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/for-in-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/for-in-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="for-in-示例"><br><img src="/myImg/javascript/array/bianli/for-in-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/for-in-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="for-in-结果"></p><h2 id="9-for…of"><a href="#9-for…of" class="headerlink" title="9, for…of"></a>9, for…of</h2><p><strong>JavaScript 版本:</strong> ECMAScript 6<br><strong>兼容性:</strong> Chrome 38+, Edge 12+, Firefox 13+, IE 全挂, Opera 25+, Safari 7+<br><strong>作用:</strong> ES 6 新增遍历所有数据结构的统一的方法。<br><strong>语法:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable <span class="keyword">of</span> object) &#123;</span><br><span class="line">  <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>variable: 必选, 对象的 value 值(数组的值)</li><li>object: 必选, 要遍历的对象(数组)</li><li>statement: 执行语句</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/for-of-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/for-of-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="for-of-示例"><br><img src="/myImg/javascript/array/bianli/for-of-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/for-of-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="for-of-结果"></p><h2 id="10-reduceRight"><a href="#10-reduceRight" class="headerlink" title="10, reduceRight()"></a>10, reduceRight()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 3<br><strong>兼容性:</strong> IE 9+, Firefox 3.0, Safari 4.0, Opera 10.5<br><strong>作用:</strong> 功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加。<br><strong>语法:</strong> array.reduceRight(参数一, 参数二)</p><ul><li>参数一: function(total, currentValue, currentIndex, arr)<ul><li>total: 初始值 或者 数组中的第一个值 或者 前n项和, 必选</li><li>currentValue: 当前值, 必选</li><li>currentIndex: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: initialValue</li><li>初始值, 传递给回调函数(参数一)的初始值, 可选值</li><li>返回值: 计算后的结果</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/reduceRight-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/reduceRight-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="reduceRight-示例"><br><img src="/myImg/javascript/array/bianli/reduceRight-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/reduceRight-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="reduceRight-结果"></p><h2 id="11-find"><a href="#11-find" class="headerlink" title="11, find()"></a>11, find()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 6<br><strong>兼容性:</strong> Chrome 45+, Edge 12+, Firefox 25+, IE 全挂, Opera 32+, Safari 8+<br><strong>作用:</strong> 查找数组中是否存在满足条件(由参数一函数提供)的数据</p><ul><li>注意: 一旦查找到满足条件的元素, 则不再继续往后检索. 如果查找不到, 返回 undefined<br><strong>语法:</strong> array.find(参数一, 参数二)</li><li>参数一: 回调函数 function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: 可选值, 回调时this是谁, 如果不写, 那么回调函数的this是全局对象, thisValue</li><li>返回值: 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined。</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/find-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/find-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="find-示例"><br><img src="/myImg/javascript/array/bianli/find-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/find-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="find-结果"></p><h2 id="12-findIndex"><a href="#12-findIndex" class="headerlink" title="12, findIndex()"></a>12, findIndex()</h2><p><strong>JavaScript 版本:</strong> ECMAScript 6<br><strong>兼容性:</strong> Chrome 45+, Edge 12+, Firefox 25+, IE 全挂, Opera 32+, Safari 8+<br><strong>作用:</strong> 查找数组中是否存在满足条件(由参数一函数提供)的数据并返回下标</p><ul><li>注意: 一旦查找到满足条件的元素, 则不再继续往后检索. 如果查找不到, 返回 -1<br><strong>语法:</strong> array.findIndex(参数一, 参数二)</li><li>参数一: 回调函数 function(currentValue, index, arr)<ul><li>currentValue: 当前值, 必选</li><li>index: 当前值下标, 可选</li><li>arr: 当前数组, 可选</li></ul></li><li>参数二: 可选值, 回调时this是谁, 如果不写, 那么回调函数的this是全局对象, thisValue</li><li>返回值: 返回符合测试条件的第一个数组元素的下标，如果没有符合条件的则返回 -1。</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/findIndex-1.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/findIndex-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="findIndex-示例"><br><img src="/myImg/javascript/array/bianli/findIndex-2.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/findIndex-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="findIndex-结果"></p><h2 id="13-keys，values，entries"><a href="#13-keys，values，entries" class="headerlink" title="13, keys，values，entries"></a>13, keys，values，entries</h2><p><strong>JavaScript 版本:</strong> ECMAScript 6<br><strong>兼容性:</strong></p><ul><li>keys(): Chrome 38+, Edge 12+, Firefox 28+, IE 全挂, Opera 25+, Safari 8+</li><li>values(): Chrome 66+, Edge 12+, Firefox 60+, IE 全挂, Opera 53+, Safari 9+</li><li>entries(): Chrome 38+, Edge 12+, Firefox 28+, IE 全挂, Opera 25+, Safari 8+<br><strong>作用:</strong> ES6 提供三个新的方法 —— entries()，keys()和values(), 用于遍历数组。<br>它们都返回一个遍历器对象，可以用for…of循环进行遍历<br>唯一的区别是:</li><li>keys()是对键名的遍历</li><li>values()是对键值的遍历</li><li>entries()是对键值对的遍历<br><strong>语法:</strong> 略</li></ul><p>示例:<br><img src="/myImg/javascript/array/bianli/KVE.png" class="lazyload placeholder" data-srcset="/myImg/javascript/array/bianli/KVE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="KVE-示例"></p><h1 id="额外放送-数组转字符串"><a href="#额外放送-数组转字符串" class="headerlink" title="额外放送: 数组转字符串"></a>额外放送: 数组转字符串</h1><ol><li>join()</li><li>toString()</li></ol><p>join() 方法可以以特定字符将数组拼成字符串, toString() 方法是直接拼接数组中的每一个值, 以 “,” 间隔<br>join() 和 toString() 方法会将空位视为 undefined, 而 undefined 和 null 会被处理成空字符串</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 数组遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React+TypeScript项目创建</title>
      <link href="/2022/04/27/react-typescript-xiang-mu-chuang-jian/"/>
      <url>/2022/04/27/react-typescript-xiang-mu-chuang-jian/</url>
      
        <content type="html"><![CDATA[<p>​- 本文主要叙述基于 TypeScript 的 React 项目创建。</p><p>可采取两个工具来创建：<strong>create-react-app</strong>(React官方提供)、<strong>vite</strong>(不仅仅是创建React项目，Vue等也可用)</p><p>每种工具都列出 <strong>npm</strong> 和 <strong>yarn</strong> 两种使用方式</p><h2 id="一，create-react-app"><a href="#一，create-react-app" class="headerlink" title="一，create-react-app"></a>一，create-react-app</h2><h3 id="1，npm"><a href="#1，npm" class="headerlink" title="1，npm"></a>1，npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app@latest XXX(项目名称) --template typescript</span><br></pre></td></tr></table></figure><p>@latest 是使用 create-react-app 的最新版本来创建项目</p><p>–template typescript 是使用 ts 来创建项目</p><ul><li>注：npm 与 npx 的关系自行百度。</li></ul><h3 id="2，yarn"><a href="#2，yarn" class="headerlink" title="2，yarn"></a>2，yarn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create react-app XXX(项目名称) --template typescript</span><br></pre></td></tr></table></figure><ul><li>注意：这里 create 后面是 空格</li></ul><h2 id="二，vite"><a href="#二，vite" class="headerlink" title="二，vite"></a>二，vite</h2><h3 id="1，npm-1"><a href="#1，npm-1" class="headerlink" title="1，npm"></a>1，npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest</span><br></pre></td></tr></table></figure><p>然后根据自己的项目需求和终端提示，人性化选择即可。</p><h3 id="2，yarn-1"><a href="#2，yarn-1" class="headerlink" title="2，yarn"></a>2，yarn</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn create vite</span><br></pre></td></tr></table></figure><p>同上，接下来也是一系列选择项。</p><h2 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h2><p>vite 的创建速度要比 create-react-app 快很多，并且 vite 不仅仅可以创建 React 项目，还可以创建 Vue 等其他框架项目。但是，create-react-app 是 React 官方提供的工具！</p><p>​本章完.</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>schannel: failed to receive handshake, SSL/TLS connection failed</title>
      <link href="/2022/01/06/schannel-failed-to-receive-handshake-ssl-tls-connection-failed/"/>
      <url>/2022/01/06/schannel-failed-to-receive-handshake-ssl-tls-connection-failed/</url>
      
        <content type="html"><![CDATA[<p>​<br>使用 GitHub Desktop 在 fetch 时突然报错，如下：</p><p>错误信息：schannel: failed to receive handshake, SSL&#x2F;TLS connection failed<br><img src="/myImg/github/githubtools/githubdesktoperror1.png" class="lazyload placeholder" data-srcset="/myImg/github/githubtools/githubdesktoperror1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="GitHub Desktop 错误信息截图"></p><p>解决方式：</p><p>在 C盘 个人用户中找到 .gitconfig 文件，设置或修改以下内容，然后解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    sslbackend = openssl</span><br></pre></td></tr></table></figure><p>问题解决。 </p>]]></content>
      
      
      <categories>
          
          <category> GitHubDesktop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHubDesktop </tag>
            
            <tag> GitHubDesktop报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koa项目搭建</title>
      <link href="/2021/07/08/koa-xiang-mu-da-jian/"/>
      <url>/2021/07/08/koa-xiang-mu-da-jian/</url>
      
        <content type="html"><![CDATA[<ul><li>最近发现使用 Koa 创建项目的博客比较多，但是不够细致，为方便自己和他人，遂整理本博客。</li></ul><p><strong>本博客会介绍以下内容：</strong></p><ol><li>安装Koa脚手架，即 koa-generator</li><li>创建 Koa 1+ 项目</li><li>创建 Koa 2+ 项目</li><li>坑</li><li>项目运行</li></ol><p><strong>建议阅读完博客之后再下手操作！！！</strong></p><h2 id="一，安装Koa脚手架"><a href="#一，安装Koa脚手架" class="headerlink" title="一，安装Koa脚手架"></a>一，安装Koa脚手架</h2><p>终端执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g koa-generator</span><br></pre></td></tr></table></figure><h2 id="二，创建-Koa-1-项目"><a href="#二，创建-Koa-1-项目" class="headerlink" title="二，创建 Koa 1+ 项目"></a>二，创建 Koa 1+ 项目</h2><p>终端执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa -e my-app</span><br></pre></td></tr></table></figure><p>-e：代表使用 ejs 模板来创建工程</p><p>my-app：工程名字</p><p>下图是package.json文件中关于Koa版本相关信息：<br><img src="/myImg/koa/create/koa1-1.png" class="lazyload placeholder" data-srcset="/myImg/koa/create/koa1-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Koa版本相关信息"></p><h2 id="三，创建-Koa-2-项目"><a href="#三，创建-Koa-2-项目" class="headerlink" title="三，创建 Koa 2+ 项目"></a>三，创建 Koa 2+ 项目</h2><p>终端执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa2 -e my-app</span><br></pre></td></tr></table></figure><p>下图是package.json文件中关于Koa版本相关信息：<br><img src="/myImg/koa/create/koa2-1.png" class="lazyload placeholder" data-srcset="/myImg/koa/create/koa2-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Koa版本相关信息"></p><h2 id="四，坑"><a href="#四，坑" class="headerlink" title="四，坑"></a>四，坑</h2><p>使用 koa 创建的是 1.0 版本的项目，使用 koa2 创建的是 2.0 版本的项目。</p><p>也正是这个坑，才促使我写的这篇博客。</p><h2 id="五，项目运行"><a href="#五，项目运行" class="headerlink" title="五，项目运行"></a>五，项目运行</h2><p>使用 步骤二（创建的Koa项目） 或者 步骤三（创建的Koa2项目）之后，依次运行以下指令，即可运行项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm i</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>启动完成之后，在浏览器输入：<a href="http://localhost:3000/">http://localhost:3000</a> 即可查看已配置好项目<br><img src="/myImg/koa/create/koa2-2.png" class="lazyload placeholder" data-srcset="/myImg/koa/create/koa2-2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="启动项目"></p><p>本集完！</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Koa </tag>
            
            <tag> Koa2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm与cnpm相互切换</title>
      <link href="/2021/06/08/npm-yu-cnpm-xiang-hu-qie-huan/"/>
      <url>/2021/06/08/npm-yu-cnpm-xiang-hu-qie-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="今天主要是来聊一聊关于-npm-的管理这个话题。"><a href="#今天主要是来聊一聊关于-npm-的管理这个话题。" class="headerlink" title="今天主要是来聊一聊关于 npm 的管理这个话题。"></a>今天主要是来聊一聊关于 npm 的管理这个话题。</h1><ul><li>前情提要：当前操作基于 Mac 系统，Windows 系统下未做验证。</li></ul><p><strong>那什么是 npm 呢？</strong><br>NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。<br><strong>你可以这样理解：</strong> npm 呢就像是个管家，管理着 nodejs 的所有包（也就是资源）。</p><p>那为什么存在 npm 和 cnpm 转换的话题呢？</p><p>npm 这个管家，他的服务器在国外，国内访问有时就会比较慢，所以，乐于分享的 淘宝团队（感谢淘宝团队的无私贡献）做了一件事，做了 <a href="https://npmmirror.com/">npm 镜像站</a>在国内，感兴趣的朋友可以去官网看看。<br>npm 镜像站官网：“这是一个完整 npmjs.com 镜像，你可以用此代替官方版本(只读)，我们将尽量与官方服务实时同步。”</p><p>实时同步时间，分钟级别，再次感谢淘宝团队的无私奉献。这跟某些博客网站逐渐要收费（不要脸）来看完整博客，形成了鲜明对比！</p><p>你可以通过多种方式来修改镜像源：</p><h2 id="一，cnpm"><a href="#一，cnpm" class="headerlink" title="一，cnpm"></a>一，cnpm</h2><p>我们可以使用 淘宝 定制的cnpm命令行工具代替默认的 npm，这样的话，以后你在每次要执行 npm 相关的操作时，要换成 cnpm 来执行。<br>我的理解，这样做的好处是提醒自己，我切换了 npm 的镜像源为淘宝提供的镜像源。<br>但是，使用 cnpm 时需要注意：淘宝镜像源官网“cnpm 支持除了<strong>写</strong>相关操作外的所有命令，例如 install、info、view 等。”</p><p>打开终端, 输入以下指令，即可实现上述操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h2 id="二，直接通过添加-npm-参数-alias-一个新命令"><a href="#二，直接通过添加-npm-参数-alias-一个新命令" class="headerlink" title="二，直接通过添加 npm 参数 alias 一个新命令"></a>二，直接通过添加 npm 参数 alias 一个新命令</h2><p>坦白讲，这种方式我没操作过，个人不喜欢这种配置参数的方式，因为时间长了，我自己就会忘记有没有配置什么参数，特别是在频繁切换 公司电脑 和 个人电脑 的使用环境下，更容易混淆。<br>这种方式的终端指令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cnpm=<span class="string">&quot;npm --registry=https://registry.npmmirror.com \ --cache=<span class="variable">$HOME</span>/.npm/.cache/cnpm \ --disturl=https://npmmirror.com/mirrors/node \ --userconfig=<span class="variable">$HOME</span>/.cnpmrc&quot;</span></span><br></pre></td></tr></table></figure><h2 id="三，切换-npm-镜像源地址"><a href="#三，切换-npm-镜像源地址" class="headerlink" title="三，切换 npm 镜像源地址"></a>三，切换 npm 镜像源地址</h2><p>这种方式，以后你还是使用 npm 来执行相关操作，只是切换镜像源为 淘宝镜像源了。<br>终端指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>想要再切换回 npm 自己默认的镜像源的话，指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h2 id="四，nrm"><a href="#四，nrm" class="headerlink" title="四，nrm"></a>四，nrm</h2><p>大家可能知道 nvm，一个 node 个版本管理工具，我这里也有一篇博客关于 nvm 使用的。<br>这个 nrm 干嘛的呢？专门用来管理 npm 源地址的工具。使用方式（最下方有完整操作截图）：<br>通过以下指令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nrm -g</span><br></pre></td></tr></table></figure><ul><li>PS：个人建议，先切换 淘宝镜像源，再安装 nrm，之后再把 npm 镜像源设置为默认的源。接下来再使用 nrm 来管理 npm。</li><li>为啥呢？直接使用 npm 默认源加载 nrm 时间超长。。。</li></ul><p>安装完成之后，可通过以下指令输出 nrm 的版本号来确认安装是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm -V</span><br></pre></td></tr></table></figure><p><img src="/myImg/npm/manage/manage1.png" class="lazyload placeholder" data-srcset="/myImg/npm/manage/manage1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="nrm版本号"></p><p>可通过如下指令查看所有源地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>使用以下指令切换源地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nrm use XXX</span><br></pre></td></tr></table></figure><p>可再次使用 nrm ls 查看源地址是否配置成功。<br>以下是我的操作截图：<br><img src="/myImg/npm/manage/manage2.png" class="lazyload placeholder" data-srcset="/myImg/npm/manage/manage2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="操作截图"></p><p>另外，以下指令可以查看当前使用的 npm 源地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>最后，一个个人习惯：<br>使用 npm 默认的源地址，虽然有时会慢，大多数时候，加载时间还能接受，只有在 npm 加载特别慢时，会选择切换淘宝镜像源地址来加载，但是加载完毕之后，还是会切回 npm 的默认源地址。个人强迫症，不喜勿喷！</p><p>完整操作截图：<br><img src="/myImg/npm/manage/manage3.png" class="lazyload placeholder" data-srcset="/myImg/npm/manage/manage3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="完整操作截图"></p><p><strong>注意</strong><br>使用 nvm 切换 node 版本之后，需要重新配置 nrm。<br>也就是说，nrm 只管理当前 node 版本下的 npm。<br>我是有使用 nvm 来管理 node 版本，才会有这个情况出现，如果不使用 nvm 管理 node，在 node 升级之后，是否需要再次配置 nrm 就需要朋友你自行尝试了。</p><p>本章完.</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> cnpm </tag>
            
            <tag> nrm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的my.ini文件</title>
      <link href="/2021/06/05/mysql-de-my-ini-wen-jian/"/>
      <url>/2021/06/05/mysql-de-my-ini-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>my.ini内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=E:\MySQL\mysql-8.0.16-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=E:\MySQL\mysql-8.0.16-winx64\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">#设置协议认证方式(重点啊) (默认使用“mysql_native_password”插件认证)</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目SEO的另一种思路</title>
      <link href="/2021/05/11/vue-xiang-mu-seo-de-ling-yi-chong-si-lu/"/>
      <url>/2021/05/11/vue-xiang-mu-seo-de-ling-yi-chong-si-lu/</url>
      
        <content type="html"><![CDATA[<p><strong>vue-meta-info 官方地址： <a href="https://github.com/muwoo/vue-meta-info">monkeyWangs&#x2F;vue-meta-info</a></strong><br>（设置vue 单页面meta info信息，如果需要单页面SEO，可以和 prerender-spa-plugin形成更优的配合）</p><p>单页面应用在前端正大放光彩。三大框架 Angular、Vue、React，可谓妇孺皆知。随着单页面应用的普及，人们在感受其带来的完美的用户体验，极强的开发效率的同时，也似乎不可避免的要去处理 SEO 的需求。</p><p>本文主要针对 vue 2.0 单页面 Meta SEO 优化展开介绍：</p><p>其实解决SEO问题不一定非得用服务端渲染来处理，服务端渲染对于刚接触 vue 的新手来说，并不是那么友好，虽然已有官方 SSR 中文文档。但是对于一个已经开发完毕的 vue 项目去接 SSR 无论是从工作量还是技术角度来说，都是一种挑战。不过这些怎么能难得到伟大的前端程序员！</p><ul><li>如果您调研服务器端渲染(SSR)只是用来改善少数营销页面（例如 &#x2F;, &#x2F;about, &#x2F;contact 等）的 SEO，那么您可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将您的前端作为一个完全静态的站点。</li><li>如果您使用 webpack，您可以使用 prerender-spa-plugin 轻松地添加预渲染。它已经被 Vue 应用程序广泛测试。</li></ul><p>预渲染为SEO提供了另一种可能，简单的来说，预渲染就是当vue-cli构建的项目进行npm run build 的时候，会按照路由的层级进行动态渲染出对应的html文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">PrerenderSpaPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PrerenderSpaPlugin</span>(</span><br><span class="line">      <span class="comment">// 编译后的html需要存放的路径</span></span><br><span class="line">      path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">      <span class="comment">// 列出哪些路由需要预渲染</span></span><br><span class="line">      [ <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/about&#x27;</span>, <span class="string">&#x27;/contact&#x27;</span> ]</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会生成类似于这样的目录结构<br><img src="/myImg/vue/seo/seosl2-1.jpeg" class="lazyload placeholder" data-srcset="/myImg/vue/seo/seosl2-1.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="目录结构"></p><p>而里面的内容都会被渲染成了静态的 html 文件</p><p><img src="/myImg/vue/seo/seosl2-2.jpeg" class="lazyload placeholder" data-srcset="/myImg/vue/seo/seosl2-2.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="静态的 html 文件"></p><p>相对于之前的可能只有</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>tangeche-pc<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以直观的发现，预渲染的作用。</p><p>有了预渲染，我们可以解决很多方面的SEO的问题，但是有时候我们也会需要Meta信息的变化，比如 title 比如 Meta keyWords 或者是 link…</p><p>这里安利一下 vue-meta-info 一个可以动态设置meta 信息的vue插件如果需要单页面SEO，可以和 prerender-spa-plugin形成更优的配合。</p><p>vue-meta-info 是一个基于 vue 2.0 的插件，它会让你更好的管理你的 app 里面的 meta 信息。你可以直接 在组件内设置 metaInfo 便可以自动挂载到你的页面中。如果你需要随着数据的变化，自动更新你的 title、meta 等信息，那么用此 插件也是再合适不过了。 当然，有时候我们也可能会遇到让人头疼的 SEO 问题，那么使用此插件配合 prerender-spa-plugin 也是再合适不过了</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>yarn 和 npm 根据自己的配置, 二选一.<br>yarn:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue-meta-info</span><br></pre></td></tr></table></figure><p>npm:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-meta-info --save</span><br></pre></td></tr></table></figure><h2 id="2-全局引入-vue-meta-info"><a href="#2-全局引入-vue-meta-info" class="headerlink" title="2.全局引入 vue-meta-info"></a>2.全局引入 vue-meta-info</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MetaInfo</span> <span class="keyword">from</span> <span class="string">&#x27;vue-meta-info&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">MetaInfo</span>)</span><br></pre></td></tr></table></figure><h2 id="3-组件内静态使用-metaInfo"><a href="#3-组件内静态使用-metaInfo" class="headerlink" title="3.组件内静态使用 metaInfo"></a>3.组件内静态使用 metaInfo</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">metaInfo</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">title</span>: <span class="string">&#x27;My Example App&#x27;</span>, <span class="comment">// set a title</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">meta</span>: [&#123;                 <span class="comment">// set meta</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;keyWords&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">content</span>: <span class="string">&#x27;My Example App&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;]</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">link</span>: [&#123;                 <span class="comment">// set link</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">rel</span>: <span class="string">&#x27;asstes&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">href</span>: <span class="string">&#x27;https://assets-cdn.github.com/&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-如果你的-title-或者-meta-是异步加载的，那么你可能需要这样使用"><a href="#4-如果你的-title-或者-meta-是异步加载的，那么你可能需要这样使用" class="headerlink" title="4.如果你的 title 或者 meta 是异步加载的，那么你可能需要这样使用"></a>4.如果你的 title 或者 meta 是异步加载的，那么你可能需要这样使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&#x27;async&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    metaInfo () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">pageName</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    data () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">pageName</span>: <span class="string">&#x27;loading&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    mounted () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">pageName</span> = <span class="string">&#x27;async&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写到这里，大家应该都明白了我所说的 SEO 的另一种思路是什么了，preRender + metaInfo</p><p>可以才一定层次上去解决 SEO 问题，这种方式优点就是代码侵入性最低，开发成本最少。但是也是有弊端的：</p><ul><li>不能很好地处理用户独特性路由: 比如有个路由是 &#x2F;my-profile, 预渲染可能不会很好用, 因为这个内容页是根据用户信息变化的，所以页面内容也不是唯一确定的. 你可能会使用类似于这样的路由路径 &#x2F;users&#x2F;:username&#x2F;profile,但是这样也是不合适的.</li><li>经常变动的文件</li><li>需要预渲染成千上万的路由文件: 这个可能会导致你编译时间…..额，可能你会编译很长时间</li></ul><p>本章完, 希望对你有帮助.</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> SEO优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目SEO优化问题二</title>
      <link href="/2021/05/11/vue-xiang-mu-seo-you-hua-wen-ti-er/"/>
      <url>/2021/05/11/vue-xiang-mu-seo-you-hua-wen-ti-er/</url>
      
        <content type="html"><![CDATA[<ul><li>以下是上节提到的那篇文章</li></ul><p>前言<br>如果开发需要复杂交互的 Web 应用，我们多半会选择 SPA；如果要做提供内容资讯的网站，更有利于 SEO、加载速度更快的服务器端渲染（Server-Side Rendering，SSR）自然是大家的首选；那么，如果是一个 CMS 生成纯静态网页呢？</p><p>前阵子公司官网升级，我尝试用 Webpack 多页配置，成功的升级了工具链，收获了比较理想的效果。我还写了一篇 Chat 分享这期间的收获：《升级工具链吧！使用 Webpack 开发企业官网》。实际运行一阵子之后，我发现一些新问题：这套技术链对于非前端开发者来说，还真算不上简单，开发环境搭建、不同文件的功用，对后端同事来说仍然显得很复杂。于是，有时候虽然只是小小的文案错误，也要找我来改；或者“加入我们”页面里的岗位信息，也需要熟悉代码的前端负责增删。</p><p>于是我就想，能否把各页面以 Vue 组件的形式搭建起来，每个组件可以有“编辑&#x2F;显示”两个状态，在本地启动开发环境，在浏览器里“编辑”内容，用户可以获得所见即所得的体验。最后以“显示”状态渲染成静态页，继续使用纯静态的方式部署。这就相当于，基于原先的项目开发一个所见即所得 CMS，把原先的静态 HTML（或 Pug）页面改造成 Vue 页面，然后利用 Vue 的 SSR 机制发布成纯静态 HTML。感觉上是个不错的想法。</p><p>我以前只是听说过 SSR，一直没有实操经验，有了这个想法之后，就想研究下这个过程，搞个最小用例，将来官网升级 3.0 的时候可以考虑。我本以为只是举手之劳，最多 1，2 个小时就搞定了，没想到最后折腾了大半天。所以我觉得，很有必要再写一篇 Chat，分享这个过程中的收获。</p><p>本次分享大纲如下：</p><p>1, 网页形态的历史<br>2, Vue CMS 的产品形态<br>3, 了解 Nuxt.js<br>4, 生成静态页的相关配置<br>5, 添加 SEO 关键信息<br>6, 注入专有 JS</p><p>面向读者<br>1, 初中级开发者，熟悉 Vue<br>2, 希望了解前端工具链<br>3, 希望了解静态化和 Nuxt.js</p><p>名词及约定<br>我假定所有读者都是有一定经验的开发者，大家至少都具备：</p><p>1, 能读懂 JavaScript<br>2, 了解 Vue，使用过 Vue 开发项目<br>3, 知道 Webpack，了解前端工具链中各工具的角色和基础用法</p><p>其它约定：<br>1, 为节省时间，范例代码中的 HTML 会以 pug 书写，这种语言很容易阅读，文中也用不到高级语法，应该问题不大。另外，如果你还在写原生 HTML 或 CSS，我建议你尽快切换到新语言。<br>2, 范例代码以 ES6+ 为基础，如果你对这些“新”语法不熟悉，附录里有一些资源方便你学习。</p><p>名词：</p><p>1, SEO：搜索引擎优化。指改进网页，让搜索引擎更容易理解它的内容，提高页面的排名。<br>2, CMS：发布系统。没有特指的话，特指本文中发布静态页的工具。</p><p>文中代码的目标环境：</p><p>1, Vue &gt;&#x3D; 2.6<br>2, Vue-router &gt;&#x3D; 3.1<br>3, Nuxt.js &gt;&#x3D; 2.8</p><p>作者介绍<br>大家好，我叫翟路佳，花名“肉山”，这个名字跟 Dota 没关系，从高中起伴随我到现在。</p><p>我热爱编程，喜欢学习，喜欢分享，从业十余年，投入的比较多，学习积累到的也比较多，对前端方方面面都有所了解，希望能与大家分享。</p><p>我兴趣爱好比较广泛，尤其喜欢旅游，欢迎大家相互交流。</p><p>我目前就职于 OpenResty Inc.，定居广州。</p><p>你可以在这里找到我：</p><p><a href="https://blog.meathill.com/">博客</a><br><a href="https://weibo.com/meathill">微博</a><br><a href="https://mp.csdn.net/mp_blog/manage/creative?utm_source=gitchat">GitChat</a><br>或者通过 <a href="mailto:meathill@gmail.com">邮件</a> 联系我。</p><p>限于个人能力、知识视野、文字技术不足，文中难免有疏漏差错，如果你有任何疑问，欢迎在任何时间通过任何形式向我提出，我一定尽快答复修改。</p><p>再次感谢大家。</p><p>网页形态的发展<br>在正式开始之前，先介绍一下网页形态发展的历史，方便大家理解。</p><p>远古时期：纯静态</p><p>发明 HTML 的目的是方便大家看论文文献，所以早期的 HTML 都是静态的，放在服务器上，直接映射本地文件目录结构。</p><p>当然那个时候也没多少网页，很多服务并没有网页版本，比如论坛，是以 Telnet 形式提供服务的；文件共享，大多使用 FTP。</p><p>古典时期：动态网站</p><p>所谓“动态网站”，就是根据用户请求，返回合适的内容。或者换用技术的说法，接受请求之后，从数据库中读取数据，生成页面，返回给用户。其实现在没什么网站不是动态网站了，感觉这是个上个世纪的词，比如去京东上搜“动态网站”，能搜到一大堆书，大多有着深刻的时代印记，比如《ASP+Dreamweaver动态网站开发》，简直辣眼睛。</p><p>文艺复兴：伪静态</p><p>相比于纯静态网站而言，动态网站通常需要更长的响应时间，而且 URL 也经常难以阅读。比如：&#x2F;post.php?id&#x3D;157，没人知道它是什么意思。这个时期的搜索引擎也比较弱，面对类似的网页，会降低权重。所以网站运营方要想办法改进 SEO，就用服务器 rewrite 的方式，把形似静态页的路径指向动态路径，提升搜索排名。</p><p>伪静态常常和真静态共同工作，这个阶段 CDN 还不够普及，所以生成静态页面并部署到终端服务器的操作也很常见。</p><p>近代：SPA</p><p>随着各项技术的发展，浏览器在整个互联网产品中的地位越来越重要，承担的职责也越来越多，最终单页应用（Single Page Application，简称 SPA）脱颖而出，成为最流行的产品形态。关于它的好处我就不一一叙说了，相信大家都了解。</p><p>而接下来，MVVM 框架横空出世，一统江湖，更是大大提升了 SPA 的开发体验，同时大大降低了入门门槛。然后，类似的产品如雨后春笋搬涌现。</p><p>现代：SPA + SSR</p><p>SEO 的问题在 SPA 这里更明显：对于一些不思进取的搜索引擎爬虫来说，SPA 应用里什么内容都没有。而不思进取，是很多统治级公司、统治级产品的常态。所以没办法，它们不适配我们，我们就得去适配它们。然后，服务器端渲染（Server-Side Rendering，简称 SSR）就显得非常必要。</p><p>SPA 的 SSR 和以前的伪静态不同。伪静态时期，业务逻辑都是通过后端完成的，前端主要用来收集数据；SPA 时期，大部分业务逻辑已经移到前端，后端只负责数据校验和必要的存储。此时 SSR 的目的是让用户尽快看到第一波需要的数据，接下来的操作仍然由 SPA 负责。所以我们就面临两种选择：</p><p>1, 前后端共用一套模板，渲染后的页面拥有全部功能，可以继续与用户交互<br>2, 部分页面生成纯静态内容，可以部署在服务器上；其它重交互的部分保持 SPA，独立工作</p><p>现代分支：在本地写作的纯静态网站</p><p>随着云服务发展，现在很多网站都提供基础的静态网站托管服务，比如 GitHub Pages，我们可以使用一些工具在本地完成静态页面的批量创建工作，然后上传到服务器，拥有自己的网站。</p><p>本文的工作实际应该算到这个分支。</p><p>Vue CMS 的产品形态<br>回顾完历史，我们来看看业务需求。</p><p>看过我上一次 Chat 《升级工具链吧！使用 Webpack 开发企业官网》的同学应该知道，一切都源自我厂的官网要改版。</p><p>我厂官网 v1.0 采用的是前文中“远古时期”的模式，由设计师设计、制作完网页之后，直接把纯静态资源上传到服务器，然后提供服务。这样的好处是：</p><p>1, 简单好操作，对人员要求低<br>2, 访问速度快，对机器配置要求低<br>3, 对搜索引擎友好</p><p>但是也有很多不足：</p><p>1, 纯静态，不利于调整内容<br>2, 不利于 i18n，没有多语言版</p><p>这些问题，我在 v2.0 时进行了修正。首先，我引入 Gulp 做批处理，增加了“发布”环节，虽然最终还是部署纯静态内容，但是内容可以简单调整，也通过 DOM 查找，实现了 i18n，同步提供中英两个语言。</p><p>新版本上线一年半，效果不错，但也有很多不足：</p><p>1, 需要开发者手动管理所有资源，很累<br>2, 发布脚本很多很复杂，不便于理解；Gulp 采用 stream 模式，没搞过的新人很难接手<br>3, 没有好的开发环境</p><p>于是，当整个页面内容都要更新时，我决定升级到 v3.0。这次使用 Webpack 工具链，采用多页面模式，配合 Pug 的可编程特性，更好的实现了最终效果，还可以配合 webpack-dev-server 方便的在本地开发。新版本大大改善了开发效率。新同事打开项目看了看 Webpack 的配置文件，很快就搞明白它是怎么工作的，如果要做工作，应该从哪里入手。</p><p>不过正如《矛盾论》所说，当主要矛盾被解决，次要矛盾就会变成新的主要矛盾。此刻，新的问题出现：专业的前端开发能很快摸清项目结构，但对于后端同事来说，未知的新概念还是很多。教会他们理解所有框架、类库、工具没什么意义，如果能够给他们一个简单可操作的 UI，那才能真正提高效率。比如 npm run edit，然后浏览器就打开一个页面。他们按需编辑后，保存，提交仓库，发布。这样的流程才是真正要追求的流程。</p><p>所以，最合适的做法就是用 Vue 实现一些编辑器组件，它们有两种形态：编辑，静态。编辑态就不用解释了；我们只要把静态的 HTML 保存下来，生成静态页，即可。</p><p>好的，现在需求已经出来了：</p><p>1, 已有一个 Vue 项目<br>2, 这个项目大部分功能由 SPA 提供，不需要静态化，不需要预渲染<br>3, 这个项目部分路由需要生成静态页<br>4, 部署的时候，只需要部署静态页和其引用的资源</p><p>看到这个需求，我想大多数关注前端的同学可能跟我一样，第一反应就是：应该找一个 SSR 框架，添加到现有项目中。那么，就选最出名的 Nuxt.js 吧，这个框架的作者还跟 Vue 的作者一起看 NBA 呢。</p><p>了解 Nuxt.js<br>Nuxt.js 的官方网站在此：<a href="https://nuxtjs.org,/">https://nuxtjs.org，</a> 大家可以先看一下。有中文版。不过需要注意，我看的时候，中文翻译并不全，而且不是一半中文一半英文的那种不全，是少了一大部分内容。后来通过 Google 搜索找到了需要的内容，我才发现中文翻译有缺失，浪费我不少时间。所以我建议，大家尽量看英文，或者，先看一遍英文，再看中文。</p><p>言归正传，接下来，我们来了解下 Nuxt.js。</p><p>定位<br>相信大家都用 Vue 开发过不止一个项目，各种组件库、工具库也都用过不少。那么 Nuxt.js 在整个 Vue 生态里，大约是个什么定位呢？</p><p>读罢官方文档的介绍，我们明白，Nuxt.js，定位于在服务器端提供 UI 渲染的通用框架。它的应用层级高于 Vue，并不打算对 Vue 的功能进行补强，而是利用 Vue 的数据双向绑定，提供更强的 B&#x2F;S 架构中服务器（Server）一端的开发环境。换句话说，它就是 Node.js 版的 Laravel。而静态页发布，也就是 nuxt generate 功能，只是服务器端渲染衍生出的一个子功能。</p><p>坦率的说，这并不是一个好消息。看过前面产品设计的同学应该明白，我想要的，实际上是类似 Vue-Router 或者 Webpack 插件一样的东西，我只要引用它，然后启动一个开关，然后 npm run build，就能生成我需要到的静态页，还有静态需要的各种静态资源。</p><p>但是在服务器端实现 Vue 模板渲染太过复杂，为了这样简单的目的，开发 Nuxt.js 这种规模的工具，实在太不划算。所以无论是 Next.js 也好，Nuxt.js 也好，他们的团队都渴望更有挑战性更有成长空间的项目，比如挑战 Laravel。（偷偷说一句，Nuxt.js 的网站上广告真多……）</p><p>作为一般用户，我只能去适应他们。</p><p>结构<br>Nuxt.js 里面集成了 Vue 全家桶和 Webpack 全家桶。好消息是这些组件我都常用，应该不会遭遇什么困难。Nuxt.js 团队还提供了脚手架创建工具，方便初始化项目。不过我的项目是现成的，所以作用不大，这个部分跳过不看。</p><p>直接在项目根目录安装 Nuxt.js：npm i nuxt -D，完成之后可以使用 nuxt -h 查看 nuxt 命令的各项参数。nuxt 命令和 vue-cli-service 一样，提供启动开发环境、build 等功能。nuxt 使用 nuxt.config.js 作为配置文件，它的地位和 vue.config.js 一样，包含了 Webpack 的默认配置，和一大堆私有配置。</p><p>所以，使用 Vue CLI 创建项目时，最好选择把所有工具的配置分散在各自的配置文件里，比如 babel 就是 .babelrc，这样复用起来更加方便。</p><p>Nuxt.js 有一套默认目录结构，使用这套目录结构可以最大限度的利用 Nuxt.js 的工作机制，不过对于我们来说，暂时排不上用场，也不需要关注。</p><p>nuxt generate</p><p>这就是最终我们要使用的命令，其实只能算作 Nuxt.js 的衍生功能。大家可以先看一下它的文档：静态应用部署以及generate 属性配置，后者需要写在 nuxt.config.js 里。</p><p>使用这个命令，会在指定的文件夹里生成预渲染文件。它的过程大概是这样：</p><p>1, nuxt 启动一个本地服务<br>2, 根据配置中的预渲染路径，生成静态页面<br>3, 把页面保存成 .html 文件，其中引用的静态资源也都保存下来<br>4, 预渲染的页面当中，包含完整的 JS 功能代码</p><p>然后我们就可以把这些静态资源整个部署到服务器上。</p><p>接下来，我们先来重构下老项目。</p><p>重构现有项目<br>理解了 Nuxt.js 的定位，就不难判断，如果我们想集成 Nuxt.js 到现有项目，必须进行一些重构。</p><p>生命周期钩子</p><p>服务器端渲染没有挂载（amount）DOM 的过程，所以自然也不支持 beforeMount 和 mounted 钩子。如果你跟我一样，习惯把初始化代码写在 beforeMount 里，那么可能有不少地方要修改。所以，以后如果有对时机要求不严的操作，最好放在 created 甚至 beforeCreated 里。</p><p>如果页面需要异步加载数据，就需要用 asyncData 函数。这个函数的用法和钩子函数类似，它需要返回 Promise 实例，真正的模板渲染会在这个 Promise 完成之后才开始。</p><p>不过需要注意，正常来说，静态页面里会包含完整的 JS，即包含完整的页面逻辑，所以钩子函数在浏览器里会照常执行。所以要避免同样的代码在 asyncData 和钩子函数里重复运行。</p><p>入口</p><p>一般来说，如果使用 Vue CLI 创建项目，入口文件是 src&#x2F;main.js，这个文件会 importsrc&#x2F;App.vue，并且 mount 到 #app 元素上。</p><p>我们当然可以继续使用这个入口，不过考虑到静态页面的依赖跟 CMS 页面的需求不同，我认为重新定义一个入口比较好。在本项目中，我把两者都需要的依赖放在 src&#x2F;App.vue 里，比如 Bootstrap 的样式；只有 CMS 需要的依赖放在 src&#x2F;main.js 里，比如 CMS 路由和 Vuex。然后在 nuxt.config.js 里重新配置路由，以 src&#x2F;App.vue 作为入口。</p><p>head</p><p>网页的头信息，包括 &lt;title&gt;，关键词（keywords）、描述（description）对 SEO 非常重要。即使不考虑 SEO，只是方便用户使用浏览器前进后退，显示正确的 &lt;title&gt; 也是应该的。在 Vue 项目中，我们使用 vue-meta 满足这个需求（vue-meta 也是 Nuxt.js 团队开发的）。</p><p>但是在 Nuxt.js 生成的静态页面里，我们需要使用 head 属性。它的用法和 vue-meta 基本一致，等下我会在具体配置里详细介绍。</p><p>生成静态页的相关配置<br>接下来讲解配置项。其实配置本身可说的部分不多，之所以铺垫这么久，正是因为我踩了很多坑。原本打算一两个小时搞定的事情，最后花费5、6个小时才摸索出来。后来我想，如果这些知识点我以前就知道，那该多好。所以才有了前面的内容。</p><p>好吧，言归正传，最终的配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">promises</span>: &#123;</span><br><span class="line">    copyFile,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">DefinePlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">&#x27;./package&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="variable constant_">POST_TABLE</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./src/model/Post&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// 用来输出 `&lt;head&gt;` 里面的信息</span></span><br><span class="line">  <span class="attr">head</span>: &#123;</span><br><span class="line">    <span class="attr">titleTemplate</span>: <span class="string">&#x27;%s - Meathill&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: [</span><br><span class="line">      &#123;<span class="attr">charset</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">name</span>: <span class="string">&#x27;viewport&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;width=device-width, initial-scale=1, user-scalable=no&#x27;</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// build 配置，其实就是封装起来的 webpack 配置</span></span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="title function_">extend</span>(<span class="params">config</span>) &#123;</span><br><span class="line">      config.<span class="property">resolve</span>.<span class="property">alias</span>[<span class="string">&#x27;@&#x27;</span>] = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extractCSS</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">        <span class="attr">VERSION</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(pkg.<span class="property">version</span>),</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新构建路由。因为静态页对 URL 的需求和 CMS 完全不同，所以这里我只针对静态页添加了简单的路由设定。</span></span><br><span class="line">  <span class="comment">// 前文说过，这里我用 `src/App.vue` 作为入口</span></span><br><span class="line">  <span class="attr">router</span>: &#123;</span><br><span class="line">    <span class="title function_">extendRoutes</span>(<span class="params">routes, resolve</span>) &#123;</span><br><span class="line">      routes.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/App.vue&#x27;</span>),</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;page.view&#x27;</span>,</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;:path&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/modules/page/page.vue&#x27;</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染配置，因为是纯静态页，所以我选择不注入业务逻辑（即 CMS 里的 JS）</span></span><br><span class="line">  <span class="comment">// 那么也就不需要 prefetch</span></span><br><span class="line">  <span class="attr">render</span>: &#123;</span><br><span class="line">    <span class="attr">injectScripts</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">resourceHints</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `nuxt generate` 的配置，只有只作用于生成的配置才写在这里，所以其实是远远不够的</span></span><br><span class="line">  <span class="attr">generate</span>: &#123;</span><br><span class="line">    <span class="attr">dir</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    <span class="attr">fallback</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">routes</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">getAllPages</span>();</span><br><span class="line">      <span class="keyword">return</span> result.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`/<span class="subst">$&#123;item.get(<span class="string">&#x27;permanentLink&#x27;</span>)&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 钩子函数，复制文件，后面会解释</span></span><br><span class="line">  <span class="attr">hooks</span>: &#123;</span><br><span class="line">    <span class="attr">generate</span>: &#123;</span><br><span class="line">      <span class="keyword">async</span> <span class="title function_">done</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/footer.js&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> to = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;static/footer.js&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">copyFile</span>(<span class="keyword">from</span>, to);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[CMS : Nuxt] Static files copied.&#x27;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里需要介绍一下 generate 属性，它的详细文档在这里：Nuxt.js &gt; Configuration &gt; The generate Property。它里面的信息是专门为 nuxt generate 准备的，但是只配置这个属性是不够的。</p><p>它的 routes 属性很重要，里面是所有要渲染的静态页。如我的例子所示，这里也可以使用异步函数，动态获取要渲染的页面列表，然后逐个渲染。Nuxt 还提供了一个优化方案，可以批量渲染页面，而不需要每次都访问数据源，不过我暂时没有用到。</p><p>添加 SEO 关键信息<br>SEO，中文全称“搜索引擎优化”，英文全称 Search Engeine Optimization，简写即 SEO。SEO 虽然名为“搜索引擎优化”，但其实优化的并不是搜索引擎，而是我们自己的页面。目的是提升我们的网页在搜索引擎中的排名。</p><p>要知道，流量是很贵的，最便宜的也要好几块&#x2F;人，那些消费能力强、消费欲望高的用户，一个可能要卖300+。所以对于老板来说，如果能够通过 SEO，让我们的网页排到更靠前的位置，引来更多的用户，那么就等于省去了很大一笔费用。所以显而易见，SEO 对他们来说吸引力很大。</p><p>对于我们前端来说，SEO 的需求不可避免，那么如何做呢？这需要我们对搜索引擎的原理有一些理解。我简单介绍一下：</p><p>1, 搜索引擎会抓取所有页面<br>2, 然后搜索引擎会分析每个页面，对内容进行分词，对每个词进行打分<br>3, 最终得到“所有网页”里“所有内容”的评分<br>4, 当用户输入搜索关键词的时候，寻找评分最高的页面倒序显示</p><ul><li>如果想了解更详细的搜索引擎知识，我推荐大家阅读吴军博士的《数学之美》，虽然我觉得他的其它作品水平不佳，但这本书科学内容比较多，还是蛮值得看的。</li></ul><p>换言之，SEO，就是要让我们的网页针对某个关键词，得分更高。一般来说，有以下工作：</p><p>1, &lt;title&gt; 里应该包含关键词<br>2, &lt;meta name&#x3D;”keywords”&gt; 里应该包含关键词<br>3, 页面内的标题，即 &lt;h1&gt;、&lt;h2&gt; 等，应该包含关键词<br>4, 图片等元素的 alt 属性，应该包含关键词<br>5, 其它正文中，应保持一些关键词密度，比如每一段，每一百个字等，都要出现至少一次关键词</p><p>具体到网站生成工作中，(3)(4)(5)通常都由运营&#x2F;编辑&#x2F;内容团队负责，我们真正能做的，就是(1)(2)，也就是接下来的组件使用。</p><p>组件</p><p>首先，在页面组件里，添加 head 属性，用来返回头信息。在本次项目中，它必须是个函数，根据页面数据动态返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">head</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">meta</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="variable language_">this</span>.<span class="property">meta</span>.<span class="property">title</span>,</span><br><span class="line">      <span class="attr">meta</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">vmid</span>: <span class="string">&#x27;keywords&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;keywords&#x27;</span>,</span><br><span class="line">          <span class="attr">content</span>: <span class="variable language_">this</span>.<span class="property">meta</span>.<span class="property">keywords</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">vmid</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">          <span class="attr">content</span>: <span class="variable language_">this</span>.<span class="property">meta</span>.<span class="property">description</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">script</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">body</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">defer</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">src</span>: <span class="string">&#x27;https://unpkg.com/swiper@4.5.0/dist/js/swiper.min.js&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">body</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">defer</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">scr</span>: <span class="string">&#x27;/footer.js&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，我们会在 nuxt.config.js 里配置默认的 meta 信息，为了避免页面的 meta 信息和默认 meta 信息重复出现，所以要用到 vmid（在组件里） 和 hid（在配置里）。这样同样 id 的头信息就只出现一个，权重当然是页面更高。</p><p>接下来 script 的部分，可以通过 body 属性控制 &lt;script&gt; 插入的位置，默认为 false，插入 &lt;head&gt;。这里当然应该放在 &lt;&#x2F;body&gt; 之前。静态网页不需要 Vue 那些很复杂的交互，所以在上一章中，我通过 render 属性把它们去掉了。但是有一些其它交互要添加进来，比如头图切换用 swiper，还有统计代码。所以要插入一个 footer.js 进去。</p><p>这里需要注意，Nuxt.js 并不会调用 webpack 去处理这里的 JS，所以我们需要人工控制它们的路径。下一章你会看到，我是直接复制文件到 static 文件夹的，所以它的路径也就写成固定的 &#x2F;footer.js。如果你有 publicPath 之类的需求，还要自己处理一下哦。</p><p>配置文件</p><p>配置文件里的内容上一章展示过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">head</span>: &#123;</span><br><span class="line">    <span class="attr">titleTemplate</span>: <span class="string">&#x27;%s - Meathill&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: [</span><br><span class="line">      &#123;<span class="attr">charset</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">name</span>: <span class="string">&#x27;viewport&#x27;</span>, <span class="attr">content</span>: <span class="string">&#x27;width=device-width, initial-scale=1, user-scalable=no&#x27;</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像没什么可说的……我暂时只用到标题模板，比如一个页面标题是“今天晚上吃什么？”，就会渲染成：“今天晚上吃什么？ - Meathill”。其它选项大家可以参考 Vue Meta &gt; API &gt; metaInfo properties。</p><p>渲染静态页的时候，vue-meta 似乎不是必须的；换言之，我一开始用了 vue-meta，没有配 head，也没有输出需要的 meta 信息。</p><p>利用钩子注入 JS<br>Nuxt.js 提供了很多钩子，方便我们在特定的环节进行定制化操作。这些钩子跟不同的操作绑定，接受不同的参数，返回不同的结果，具体钩子列表请参考 Nuxt.js &gt; API &gt; Hooks &gt; List of hooks。</p><p>在本项目中，我的需求是生成静态页面需要的 JS。这个 JS 包含两个功能：</p><p>1, 初始化 swiper<br>2, 启动统计代码</p><p>因为功能非常简单，我暂时不打算用 webpack 打包，只想复制到目标文件夹里。启动复制操作的时机并不敏感，因为和主要的生成静态页工作不存在相互依赖的关系。不过 Nuxt.js 默认会清理生成目录，所以我觉得晚一些复制会比较好，最后选择 generate:done 这个钩子（基本是最后才会执行）。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">promises</span>: &#123;</span><br><span class="line">    copyFile,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">hooks</span>: &#123;</span><br><span class="line">    <span class="attr">generate</span>: &#123;</span><br><span class="line">      <span class="keyword">async</span> <span class="title function_">done</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src/footer.js&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> to = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;static/footer.js&#x27;</span>);</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">copyFile</span>(<span class="keyword">from</span>, to);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[CMS : Nuxt] Static files copied.&#x27;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该很容易看懂吧，就是一个简单的复制。不过需要注意，copyFile 函数是 v10 之后添加到 Node.js 里的，而预 promise 化的 fs.promises 是 v12 之后添加的。</p><p>后记 &amp; 附录<br>先回顾一下本文的主要观点：</p><p>1, Nuxt.js 的目标是覆盖完整的网站开发场景，这个场景更有前（钱）途<br>2, 要达成这个目标，支持 Vue 模板的服务器渲染是必经之路<br>3, 所以生成静态页只是 Nuxt.js 的一个衍生功能<br>4, 所以在现有项目中集成 Nuxt.js ，渲染静态页的成本比较高，很多文章也提供类似的观点<br>5, 但是如果有必要，这仍然是最好操作的方案</p><p>接下来，关于技术选型：</p><p>1, 如果是新项目，必须 SSR，那么建议从开始就用 Nuxt.js 创建项目<br>2, 如果是老项目，部分页面需要静态化，请参考本文</p><p>最后，如果要在现有项目中解成 Nuxt.js，我们应该：</p><p>1, 重构现有项目，一般要重构入口和路由<br>2, 新建 nuxt.config.js，添加基础配置<br>3, 配置 generate 属性，生成所有要静态化的路径<br>4, 如果不需要复杂的交互，可以用 render 属性移除老的 JS，然后手动添加其它的。</p><p>希望可以帮大家节省学习尝试踩坑的时间。</p><p>，</p><p>。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> SEO优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目SEO优化问题</title>
      <link href="/2021/05/11/vue-xiang-mu-seo-you-hua-wen-ti/"/>
      <url>/2021/05/11/vue-xiang-mu-seo-you-hua-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>之前用vue做了一个动态官网项目，后期客户要求seo，百度上之前搜索不到官网地址，后来在项目的入口文件index.html页面加上了，固定的meta标签，加上name名为keywords、description的meta标签。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">// 下面这个meta标签 是ie8的专用标记，指定ie8浏览器器模拟特定版本的ie浏览器渲染方式，下面指定的是edge</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span></span><br><span class="line">// 在ie、360等浏览器打开时，默认使用极速模式，然后是兼容模式，然后是标准模式</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit|ie-comp|ie-stand&quot;</span>&gt;</span></span><br><span class="line">// seo相关，百度收录时，的描述文字</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;第十七届xxxxx医学大会&quot;</span>&gt;</span></span><br><span class="line">// seo相关：百度搜索时的 关键字，就是用那些关键字可以搜索到此网站</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;中国国际xx医学大会,第十七届,xx,医学,国际&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上做了个简单的seo优化，这个项目有几个官网，但是其中只有一个官网要求seo，也就是在百度能够搜索到，当时为了应急，就写死了，但是，其它的网站也就会受到干扰了，也就是对于一个项目对应几个官网，写死的meta标签做seo是不科学的。</p><p>于是下面又来寻找更科学的seo优化方案，下面是一些相关连接，很感谢文章作者：<a href="https://blog.csdn.net/weixin_41049850/article/details/81945201">关于vue项目的seo问题-CSDN博客</a></p><p>文中提到了关于vue单页项目的一些seo优化方案：</p><p>首先想vue、react、angular三大前端框架都有spa页面，做起来seo就很麻烦，当然，不是必须要求用这三个框架就必须采用spa的开发模式，但是spa前后端分离的形式真的是太方便了，如果不采用spa方式进行开发，用古老的混合开发自然不会存在seo的问题，但是我们现在大多采用的是spa的形式开发的。<br><img src="/myImg/vue/seo/seo1.png" class="lazyload placeholder" data-srcset="/myImg/vue/seo/seo1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="尤大神的回答"></p><h2 id="方案1：服务端渲染"><a href="#方案1：服务端渲染" class="headerlink" title="方案1：服务端渲染"></a>方案1：服务端渲染</h2><p>上面这个截图是vue作者，为解决seo优化所提出的一个方案，服务端渲染（ssr）：官网链接：<a href="https://cn.vuejs.org/v2/guide/ssr.html">服务端渲染 — Vue.js</a></p><p>如果项目刚开始就考虑到seo，采用服务端渲染，那么就用服务端渲染就得了。</p><p>但是一般来讲，项目做到后期才会考虑到seo的问题，这时再去搞服务端渲染，相当于重头写项目，非常耗费人力物力。</p><p>那么，不采用服务端渲染该如何最大程度解决seo问题呢？</p><h2 id="方案2：预渲染"><a href="#方案2：预渲染" class="headerlink" title="方案2：预渲染"></a>方案2：预渲染</h2><p>原文链接：<a href="https://www.cnblogs.com/kdcg/p/9606302.html">https://www.cnblogs.com/kdcg/p/9606302.html</a></p><p>这比服务端渲染要简单很多，而且可以配合 <a href="https://www.npmjs.com/package/vue-meta-info">vue-meta-info</a> 来生成 title 和 meta 标签，基本可以满足 SEO 的需求 </p><p><strong>TIPS: 使用预渲染vue-router必须使用history模式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm install prerender-spa-plugin --save-dev</span><br></pre></td></tr></table></figure><p>然后在webpack.prod.conf.js里面添加：cli3项目在vue.config.js文件中配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 头部引入</span><br><span class="line">const PrerenderSPAPlugin = require(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line">const Renderer = PrerenderSPAPlugin.PuppeteerRenderer</span><br></pre></td></tr></table></figure><p>在plugins里面添加：</p><p>config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CompressionPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;compression-webpack-plugin&#x27;</span>);<span class="comment">//引入gzip压缩插件</span></span><br><span class="line"><span class="comment">// 预渲染</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PrerenderSPAPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Renderer</span> = <span class="title class_">PrerenderSPAPlugin</span>.<span class="property">PuppeteerRenderer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">dir</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">　　<span class="comment">// 选项...</span></span><br><span class="line">    <span class="comment">//基本路径</span></span><br><span class="line">    <span class="attr">publicPath</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span>? <span class="string">&#x27;/&#x27;</span>: <span class="string">&#x27;/&#x27;</span>,<span class="comment">//部署服务器的路径 默认在根路径上(影响静态资源的引用路径)</span></span><br><span class="line">    <span class="attr">outputDir</span>: <span class="string">&#x27;customizationWeb&#x27;</span>,</span><br><span class="line">    <span class="attr">assetsDir</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    <span class="attr">productionSourceMap</span>:<span class="literal">false</span>,<span class="comment">//打包时不要map文件</span></span><br><span class="line">    <span class="comment">// filenameHashing: true,</span></span><br><span class="line">　　<span class="attr">devServer</span>: &#123;</span><br><span class="line">    　　<span class="attr">port</span>: <span class="number">9522</span>,</span><br><span class="line">        <span class="attr">proxy</span>:&#123;</span><br><span class="line">          <span class="string">&#x27;/qiantai&#x27;</span>:&#123;</span><br><span class="line">            <span class="attr">target</span>:<span class="string">&#x27;http://139.xxx.xxx.xx:xxxx&#x27;</span>,</span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                <span class="string">&quot;^/qiantai&quot;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">configureWebpack</span>:<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">externals</span>: &#123;<span class="comment">//如果不想影响开发环境，这里也要配置externals  没用它的就不用在开发环境也配置一份了</span></span><br><span class="line">            <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;vuex&#x27;</span>: <span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">            <span class="comment">// &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,</span></span><br><span class="line">            <span class="string">&#x27;Axios&#x27;</span>:<span class="string">&#x27;axios&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">externals</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;vuex&#x27;</span>: <span class="string">&#x27;Vuex&#x27;</span>,</span><br><span class="line">            <span class="comment">// &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,</span></span><br><span class="line">            <span class="string">&#x27;Axios&#x27;</span>:<span class="string">&#x27;axios&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CompressionPlugin</span>(&#123;<span class="comment">//gzip压缩配置</span></span><br><span class="line">              <span class="attr">test</span>:<span class="regexp">/\.js$|\.html$|\.css/</span>,<span class="comment">//匹配文件名</span></span><br><span class="line">              <span class="attr">threshold</span>:<span class="number">10240</span>,<span class="comment">//对超过10kb的数据进行压缩</span></span><br><span class="line">              <span class="attr">deleteOriginalAssets</span>:<span class="literal">false</span>,<span class="comment">//是否删除原文件</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrerenderSPAPlugin</span>(&#123;</span><br><span class="line">              <span class="comment">// 生成文件的路径，也可以与webpakc打包的一致。</span></span><br><span class="line">              <span class="comment">// 下面这句话非常重要！！！</span></span><br><span class="line">              <span class="comment">// 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span></span><br><span class="line">              <span class="attr">staticDir</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;customizationWeb&#x27;</span>),</span><br><span class="line">      </span><br><span class="line">              <span class="comment">// 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。</span></span><br><span class="line">              <span class="attr">routes</span>: [<span class="string">&#x27;/&#x27;</span>],</span><br><span class="line">      </span><br><span class="line">              <span class="comment">// 这个很重要，如果没有配置这段，也不会进行预编译</span></span><br><span class="line">              <span class="attr">renderer</span>: <span class="keyword">new</span> <span class="title class_">Renderer</span>(&#123;</span><br><span class="line">                <span class="attr">inject</span>: &#123;</span><br><span class="line">                  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 在 main.js 中 document.dispatchEvent(new Event(&#x27;render-event&#x27;))，两者的事件名称要对应上。</span></span><br><span class="line">                <span class="attr">renderAfterDocumentEvent</span>: <span class="string">&#x27;render-event&#x27;</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">chainWebpack</span>(<span class="params">config</span>) &#123;</span><br><span class="line">      <span class="comment">// set svg-sprite-loader</span></span><br><span class="line">      config.<span class="property">module</span></span><br><span class="line">        .<span class="title function_">rule</span>(<span class="string">&#x27;svg&#x27;</span>)</span><br><span class="line">        .<span class="property">exclude</span>.<span class="title function_">add</span>(<span class="title function_">resolve</span>(<span class="string">&#x27;src/icons&#x27;</span>))</span><br><span class="line">        .<span class="title function_">end</span>()</span><br><span class="line">      config.<span class="property">module</span></span><br><span class="line">        .<span class="title function_">rule</span>(<span class="string">&#x27;icons&#x27;</span>)</span><br><span class="line">        .<span class="title function_">test</span>(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">        .<span class="property">include</span>.<span class="title function_">add</span>(<span class="title function_">resolve</span>(<span class="string">&#x27;src/icons&#x27;</span>))</span><br><span class="line">        .<span class="title function_">end</span>()</span><br><span class="line">        .<span class="title function_">use</span>(<span class="string">&#x27;svg-sprite-loader&#x27;</span>)</span><br><span class="line">        .<span class="title function_">loader</span>(<span class="string">&#x27;svg-sprite-loader&#x27;</span>)</span><br><span class="line">        .<span class="title function_">options</span>(&#123;</span><br><span class="line">          <span class="attr">symbolId</span>: <span class="string">&#x27;icon-[name]&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">end</span>() </span><br><span class="line">        <span class="comment">// 打包依赖分析</span></span><br><span class="line">      <span class="comment">// config</span></span><br><span class="line">      <span class="comment">//   .plugin(&#x27;webpack-bundle-analyzer&#x27;)</span></span><br><span class="line">      <span class="comment">//   .use(require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main.js加上这点代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="attr">mounted</span>: <span class="function">() =&gt;</span> <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&quot;x-app-rendered&quot;</span>)),</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">dispatchEvent</span>(<span class="keyword">new</span> <span class="title class_">Event</span>(<span class="string">&#x27;render-event&#x27;</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><p> <br>这种操作不需要你去添加任何一段代码，直接npm run build，dist文件中就有你写的几个html静态文件。</p><p>然后运行: npm run build </p><p>发现打包好的index.html中多了一大堆的代码，部署到nginx上试试看看什么效果</p><p>下面的报错是之前用另一种方式 vue add 什么什么的全自动做预渲染的，网上可以查查，打包后会出现这些坑，第二次直接按照以上的步骤就没有下面的问题了</p><p>和其他人一样，一直打包不成功，有错误：<br><img src="/myImg/vue/seo/seoError1.png" class="lazyload placeholder" data-srcset="/myImg/vue/seo/seoError1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="其他人的错误"></p><p>然后和大佬们的一样安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><p>如果安装太慢, 可以切换 npm 镜像源, 或者使用 cnpm, 后期我也会专门写一篇关于 npm源 管理的文章.</p><p>之后再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>还是上面的报错：<br><img src="/myImg/vue/seo/seoError2.png" class="lazyload placeholder" data-srcset="/myImg/vue/seo/seoError2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="其他人继续错误"></p><p>查一下这个报错：</p><p>使用 cnpm 或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> puppeteer_download_host=https://npm.taobao.org/mirrors</span><br><span class="line">npm i puppeteer</span><br></pre></td></tr></table></figure><p>然后下载成功了，也不慢，</p><p>之后打包 npm run build</p><p>打包成功，index.html 中多了好多代码，但是本地运行项目出问题了，后续接着看</p><p>搞了半天，感觉对于纯动态的页面，预渲染好像并无卵用。因为动态获取的内容，预渲染是预渲染不出来的，还的看服务端渲染，。。。</p><p>这是一位大佬的文章，付费的哦：<a href="https://gitbook.cn/books/5d7f8b5b84257d2371a8babb/index.html">CSDN</a></p><p>想了想，我掏钱了，我就把大佬的文章偷来，给大家免费看，嘻嘻：复制粘贴走起, 篇幅有限, 另起一章吧。</p><p>详见: Vue项目SEO优化问题二</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> SEO优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React项目打包之后显示空白页</title>
      <link href="/2021/04/29/react-xiang-mu-da-bao-zhi-hou-xian-shi-kong-bai-ye/"/>
      <url>/2021/04/29/react-xiang-mu-da-bao-zhi-hou-xian-shi-kong-bai-ye/</url>
      
        <content type="html"><![CDATA[<p>​<br>环境说明:</p><p><strong>React 16</strong></p><p>React 官网创建项目方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>npm run build 打包之后, 页面空白.</p><p>解决方案:</p><p>package.json 文件中添加 homepage 字段:</p><p><img src="/myImg/react/build/buildError1.png" class="lazyload placeholder" data-srcset="/myImg/react/build/buildError1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="package.json中配置"></p><p>本章完。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> React项目打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquerylazyload中文文档</title>
      <link href="/2021/01/07/jquerylazyload-zhong-wen-wen-dang/"/>
      <url>/2021/01/07/jquerylazyload-zhong-wen-wen-dang/</url>
      
        <content type="html"><![CDATA[<p>​最近使用 jquery.lazyload.js 这个jQuery插件的时候, 突然发现对这个插件相对全面的介绍不多.</p><p>特别是对 lazyload() 方法中的配置选项的介绍少之又少.</p><p>随即整理一份供大家参阅.</p><h1 id="jquerylazyload中文文档"><a href="#jquerylazyload中文文档" class="headerlink" title="jquerylazyload中文文档"></a>jquerylazyload中文文档</h1><ul><li>说明: 我使用的版本是1.9.3</li></ul><p>废话不多少, 直接上代码, 一个使用的 Demo 示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">765px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#container</span> <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img2.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img3.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img4.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img5.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">data-original</span>=<span class="string">&quot;./image/img6.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/jquery.lazyload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">$(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  $(<span class="string">&#x27;img.lazy&#x27;</span>).<span class="title function_">lazyload</span>(&#123; <span class="attr">effect</span>: <span class="string">&quot;fadeIn&quot;</span> &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下方有完整代码链接.</p><p>上述 Demo 中仅用到了 lazyload 配置选项中的 effect 属性, 接下来介绍下该版本提供的所有属性和具体用法.</p><p>首先, 先来一张代码截图:<br><img src="/myImg/jquery/plugin/lazyload1.png" class="lazyload placeholder" data-srcset="/myImg/jquery/plugin/lazyload1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="lazyload属性"></p><p>对应代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;img.lazy&#x27;</span>).<span class="title function_">lazyload</span>(&#123;</span><br><span class="line">  <span class="comment">// threshold: 提前开始加载高度.</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// failure_limit: 同 failurelimit</span></span><br><span class="line">  <span class="attr">failure_limit</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="comment">// event: 设置何种事件触发时才加载, 默认 scroll</span></span><br><span class="line">  <span class="attr">event</span>: <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="comment">// effect: 使用何种载入效果</span></span><br><span class="line">  <span class="attr">effect</span>: <span class="string">&quot;fadeIn&quot;</span>,</span><br><span class="line">  <span class="comment">// container: 对某容器中的图片实现效果</span></span><br><span class="line">  <span class="attr">container</span>: $(<span class="string">&quot;#container&quot;</span>),</span><br><span class="line">  <span class="comment">// data_attribute: 用于设置 lazyload 操作的自定义属性(data-后面的属性名)</span></span><br><span class="line">  data_attribute : <span class="string">&quot;attr&quot;</span>,</span><br><span class="line">  <span class="comment">// skip_invisible: 是否 不加载不可见图片. true 不加载, false 加载.</span></span><br><span class="line">  skip_invisible : <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// appear: 用于在图片加载之前到显示图片之间的处理函数，一般用于展示加载动画.</span></span><br><span class="line">  <span class="attr">appear</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// load: 用于图片加载完毕之后执行的函数.</span></span><br><span class="line">  <span class="attr">load</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// placeholder: 设置占位图片路径</span></span><br><span class="line">  placeholder : <span class="string">&quot;img/lazy.gif&quot;</span>,</span><br><span class="line">  <span class="comment">// failurelimit: 一次加载图片的张数(图片排序混乱时使用)</span></span><br><span class="line">  failurelimit : <span class="number">10</span>,</span><br><span class="line">  <span class="comment">// effectspeed: 设置动画持续时长, 单位毫秒</span></span><br><span class="line">  effectspeed : <span class="number">1000</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从中可一目了然的看到所有可配置属性. 接下来逐个介绍对应属性.</p><h2 id="1-threshold-默认值-0"><a href="#1-threshold-默认值-0" class="headerlink" title="1, threshold: 默认值 0"></a>1, threshold: 默认值 0</h2><p>threshold: 值为数字, 用于设置提前开始加载高度. 如设置为200, 表示滚动条在离目标位置还有 200 的高度时就开始加载图片, 可以做到不让用户察觉.</p><h2 id="2-failure-limit-默认值-0"><a href="#2-failure-limit-默认值-0" class="headerlink" title="2, failure_limit : 默认值 0"></a>2, failure_limit : 默认值 0</h2><p>failure_limit: 值为数字, 同 failurelimit(下文介绍)</p><h2 id="3-event-默认值-“scroll”"><a href="#3-event-默认值-“scroll”" class="headerlink" title="3, event: 默认值 “scroll”"></a>3, event: 默认值 “scroll”</h2><p>event: 用于设置触发加载的时机. 值有scroll(滚动), click(点击), mouseover(鼠标划过), sporty(运动的), foobar(…).可以实现鼠标莫过或点击图片才开始加载,后两个值未测试…</p><h2 id="4-effect-默认值-“show”"><a href="#4-effect-默认值-“show”" class="headerlink" title="4, effect: 默认值 “show”"></a>4, effect: 默认值 “show”</h2><p>effect: 用于设置显示图片是的动画效果. 值有: show(直接显示), fadeIn(淡入), slideDown(下拉)等</p><h2 id="5-container-默认值-window"><a href="#5-container-默认值-window" class="headerlink" title="5, container: 默认值 window"></a>5, container: 默认值 window</h2><p>container: 值为某容器, 用于设置对某容器中的图片实现效果. lazyload默认在拉动浏览器滚动条时生效, 这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片</p><h2 id="6-data-attribute-默认值-“original”"><a href="#6-data-attribute-默认值-“original”" class="headerlink" title="6, data_attribute: 默认值 “original”"></a>6, data_attribute: 默认值 “original”</h2><p>data_attribute: 用于设置 lazyload 操作的自定义属性(data-后面的属性名)</p><h2 id="7-skip-invisible-默认值-true"><a href="#7-skip-invisible-默认值-true" class="headerlink" title="7, skip_invisible: 默认值 true"></a>7, skip_invisible: 默认值 true</h2><p>skip_invisible: 设置是否加载不可见的图片.</p><p>Lazy Load 插件默认对隐藏的图片不加载(例如 display:none ). 这样做有助于性能的优化. 如果希望连隐藏的图片一起加载,则可以把 skip_invisible 设为 false .</p><h2 id="8-appear-默认值-null"><a href="#8-appear-默认值-null" class="headerlink" title="8, appear: 默认值 null"></a>8, appear: 默认值 null</h2><p>appear: 用于在图片加载之前到显示图片之间的处理函数，一般用于展示加载动画.</p><h2 id="9-load-默认值-null"><a href="#9-load-默认值-null" class="headerlink" title="9, load: 默认值 null"></a>9, load: 默认值 null</h2><p>load: 用于图片加载完毕之后执行的函数.</p><h2 id="10-placeholder-默认值-“data-image-png-base64-iV……”"><a href="#10-placeholder-默认值-“data-image-png-base64-iV……”" class="headerlink" title="10, placeholder: 默认值 “data:image&#x2F;png;base64,iV……”"></a>10, placeholder: 默认值 “data:image&#x2F;png;base64,iV……”</h2><p>placeholder: 用于设置占位图片.</p><p>值为某一图片路径. 此图片用来占据将要加载的图片的位置, 待图片加载时, 占位图则会隐藏</p><p>接下来的两个是兼容低版本的属性, 在该版本中正常使用.</p><h2 id="11-effectspeed-毫秒数"><a href="#11-effectspeed-毫秒数" class="headerlink" title="11, effectspeed : 毫秒数"></a>11, effectspeed : 毫秒数</h2><p>effectspeed: 用于控制动画的速度.</p><p>属性默认是空的, 所以如果不设置它, 动画的时间为400毫秒.</p><h2 id="12-failurelimit-值为数字-在图片布局混乱时使用"><a href="#12-failurelimit-值为数字-在图片布局混乱时使用" class="headerlink" title="12, failurelimit: 值为数字. 在图片布局混乱时使用."></a>12, failurelimit: 值为数字. 在图片布局混乱时使用.</h2><p>Lazy Load 有一个循环查找 img 的机制. 根据 HTML 文档的布局从上往下查找, 当找到第一个并未显示&#x2F;加载的 img 时, 就会停止往下查找.(其实就是对 $(“img.lazy”) 这个对象(组)进行顺序查找)</p><p><strong>那这个 failure_limit 的属性有什么用呢?</strong></p><p>现在网站设计时, 都会用到大量的定位样式, 如: float 和 position , 这样在浏览器呈现的布局效果和 HTML 文档中的 DOM 顺序有很大差异.</p><p>这样就会存在一种情况, 某 img 标签已出现在屏幕上,但它却无法显示(因为按顺序加载的话, 还没排到它)!! </p><p>当 Lazy Load 在找到第一个未显示的 img 标签时, 查找已经被终止了, 并没有继续往下遍历.</p><p>当设置了 failure_limit 属性之后,  Lazy Load 会查找到对应个数未显示的 img 标签处.</p><p>当在图片多且布局复杂的页面时, failure_limit 的作用就很大了.</p><p>原文还温馨提示: If you have a funky layout set this number to something high.  如果你的网站布局很”变态”, 建议把该值调得更高.</p><p>在这里获取<a href="https://github.com/CoderLeoD/jquery-lazyload/tree/main">本章源码</a>.</p><p>本章结束。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery.lazyload-1.9.3中文文档 </tag>
            
            <tag> 延迟加载图片的jQuery插件 </tag>
            
            <tag> jQuery插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue用高德地图实现城市定位</title>
      <link href="/2020/12/23/vue-yong-gao-de-di-tu-shi-xian-cheng-shi-ding-wei/"/>
      <url>/2020/12/23/vue-yong-gao-de-di-tu-shi-xian-cheng-shi-ding-wei/</url>
      
        <content type="html"><![CDATA[<ul><li>说明：本文主要是介绍如何在 Vue 项目中接入高德地图并定位当前城市，更深层次的内容稍后有空整理。</li></ul><p>可能还有更牛的实现方案，目前我这里记录的是我自己跑通的一个版本，希望对你有所帮助，仅供参考。</p><p><strong>Vue项目运行环境：Vue 2.0，Vue Cli 3.0</strong></p><h1 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h1><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>登录高德地图开放平台 通过 控制台—-&gt;应用管理—-&gt;我的应用—-&gt;创建应用。创建一个新的应用，获取到 key。</p><p>截图如下：<br><img src="/myImg/vue/map/gaode/gaode1.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/gaode/gaode1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="获取key"></p><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>在index.html文件中通过 script 标签和上一步获取的 key 引入高德地图资源。</p><p>截图如下：<br><img src="/myImg/vue/map/gaode/gaode2.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/gaode/gaode2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="引入高德地图资源"></p><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>在项目的根目录中（src同级目录）创建vue.config.js文件（这个文件从Vue Cli 3.0 之后不再创建，有需要时需要我们自己手动创建）。</p><p>然后添加以下代码。代码和截图如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;AMap&#x27;</span>: <span class="string">&#x27;AMap&#x27;</span> <span class="comment">// 高德地图配置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myImg/vue/map/gaode/gaode3.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/gaode/gaode3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="config配置"></p><h2 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h2><p>在组件中通过以下代码获取定位。</p><p>代码和截图如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getLocation</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 获取定位</span></span><br><span class="line">    <span class="title function_">getLocation</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="title class_">AMap</span>.<span class="title function_">plugin</span>(<span class="string">&#x27;AMap.CitySearch&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> citySearch = <span class="keyword">new</span> <span class="title class_">AMap</span>.<span class="title class_">CitySearch</span>()</span><br><span class="line">        citySearch.<span class="title function_">getLocalCity</span>(<span class="keyword">function</span> (<span class="params">status, result</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (status === <span class="string">&#x27;complete&#x27;</span> &amp;&amp; result.<span class="property">info</span> === <span class="string">&#x27;OK&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 查询成功，result即为当前所在城市信息</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;通过ip获取当前城市：&#x27;</span>,result);</span><br><span class="line">            _this.<span class="property">autolocation</span> = result.<span class="property">city</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="/myImg/vue/map/gaode/gaode4.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/gaode/gaode4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="组件中使用"></p><p>走到这里，不出意外，你就可以获取到位置信息了。上述代码通过当前组件的 autolocation 属性接收了定位到的城市(city)信息。</p><p>本章结束。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 高德地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue用百度地图实现城市定位</title>
      <link href="/2020/12/23/vue-yong-bai-du-di-tu-shi-xian-cheng-shi-ding-wei/"/>
      <url>/2020/12/23/vue-yong-bai-du-di-tu-shi-xian-cheng-shi-ding-wei/</url>
      
        <content type="html"><![CDATA[<p>​</p><ul><li>说明：本文主要是介绍如何在Vue项目中接入百度地图并定位当前城市，更深层次的内容稍后有空整理。</li></ul><p>可能还有更牛的实现方案，目前我这里记录的是我自己跑通的一个版本，希望对你有所帮助，仅供参考。</p><p><strong>Vue项目运行环境：Vue 2.0，Vue Cli 3.0</strong></p><h1 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h1><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>登录 百度地图开放平台 在 控制台—-&gt;应用管理—-&gt;我的应用 下面创建一个应用。目的是获取 ak<br><img src="/myImg/vue/map/baidu/baidu1.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="获取 ak"></p><h2 id="步骤二：在public文件夹的index-html文件中导入百度地图，拼上你的ak"><a href="#步骤二：在public文件夹的index-html文件中导入百度地图，拼上你的ak" class="headerlink" title="步骤二：在public文件夹的index.html文件中导入百度地图，拼上你的ak"></a>步骤二：在public文件夹的index.html文件中导入百度地图，拼上你的ak</h2><p><img src="/myImg/vue/map/baidu/baidu2.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="拼 ak"></p><p>这个地址链接是百度地图给的，你可以<a href="https://lbsyun.baidu.com/index.php?title=jspopularGL/guide/helloworld">点击这个传送门去百度地图官网查看出处</a>。</p><h2 id="步骤三：在项目的根目录中创建vue-config-js文件，如果有vue-config-js文件的话，直接添加以下代码即可。"><a href="#步骤三：在项目的根目录中创建vue-config-js文件，如果有vue-config-js文件的话，直接添加以下代码即可。" class="headerlink" title="步骤三：在项目的根目录中创建vue.config.js文件，如果有vue.config.js文件的话，直接添加以下代码即可。"></a>步骤三：在项目的根目录中创建vue.config.js文件，如果有vue.config.js文件的话，直接添加以下代码即可。</h2><p>vue.config.js文件在VueCli 3.0之后就不再默认创建了，有用到这个文件的时候，需要我们手动创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;BMap&#x27;</span>: <span class="string">&#x27;BMap&#x27;</span> <span class="comment">// 百度地图配置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配上截图</p><p><img src="/myImg/vue/map/baidu/baidu3.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="config配置"></p><h2 id="步骤四：接下来就是具体的代码实现了。"><a href="#步骤四：接下来就是具体的代码实现了。" class="headerlink" title="步骤四：接下来就是具体的代码实现了。"></a>步骤四：接下来就是具体的代码实现了。</h2><p>接下来会介绍两种实现方案。</p><p>方式一（推荐使用）：单独封装js工具文件实现地址获取。</p><p>1，在src文件夹下新建util文件夹，然后在util文件夹中新建getUserLocation.js文件。</p><p>注：这个util文件夹，可以存放所有自己封装的工具js文件，不单单是getUserLocation.js这一个定位相关的文件。</p><p>代码和截图如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前城市</span></span><br><span class="line"><span class="keyword">const</span> getCurrentCityName = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> myCity = <span class="keyword">new</span> <span class="title class_">BMap</span>.<span class="title class_">LocalCity</span>();</span><br><span class="line">    myCity.<span class="title function_">get</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> geoc = <span class="keyword">new</span> <span class="title class_">BMap</span>.<span class="title class_">Geocoder</span>();</span><br><span class="line">      geoc.<span class="title function_">getLocation</span>(result.<span class="property">center</span>, <span class="function">(<span class="params">rs</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// rs 中携带着所有的定位信息，这里只获取了城市(city)和所在的区(district)</span></span><br><span class="line">        <span class="keyword">let</span> addComp = rs.<span class="property">addressComponents</span>;</span><br><span class="line">        <span class="keyword">let</span> result = addComp.<span class="property">city</span> + addComp.<span class="property">district</span>;</span><br><span class="line">        <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, &#123;<span class="attr">enableHighAccuracy</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getCurrentCityName;</span><br></pre></td></tr></table></figure><p><img src="/myImg/vue/map/baidu/baidu4.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="util文件夹"></p><p>2，在组件中引入并调用上述文件中封装的方法。</p><p>截图如下：<br><img src="/myImg/vue/map/baidu/baidu5.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="util文件夹"></p><p>不出意外的话，页面通过locationMsg属性即可显示位置信息，例如：北京市丰台区</p><p>方式一结束。</p><p>方式二：直接在组件中进行定位。</p><p>直接在组件中使用以下代码即可定位成功，这种方式耗时比方式一要长。</p><p>代码及截图如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取位置信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getCity</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getCity</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> getLocation = <span class="keyword">new</span> <span class="title class_">BMap</span>.<span class="title class_">Geolocation</span>();</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">      getLocation.<span class="title function_">getCurrentPosition</span>(<span class="function">(<span class="params">position</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// position中存放所有的定位数据</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(position);</span><br><span class="line">        <span class="comment">// 这里获取的是城市和省</span></span><br><span class="line">        <span class="keyword">let</span> city = position.<span class="property">address</span>.<span class="property">city</span>;</span><br><span class="line">        <span class="keyword">let</span> province = position.<span class="property">address</span>.<span class="property">province</span>;</span><br><span class="line">        _this.<span class="property">locationMsg</span> = province + city;</span><br><span class="line">      &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        _this.<span class="property">locationMsg</span> = <span class="string">&#x27;定位失败!&#x27;</span>;</span><br><span class="line">      &#125;, &#123;<span class="attr">provider</span>: <span class="string">&#x27;baidu&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="/myImg/vue/map/baidu/baidu6.png" class="lazyload placeholder" data-srcset="/myImg/vue/map/baidu/baidu6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="方式二"></p><p>注：这里的_this其实是没有必要的，可以直接使用this，之前没有使用箭头函数，就使用了_this，后来改成箭头函数之后，没有修改_this相关的代码。当然按照上述代码写也没有问题。</p><p>不出意外，就可以在组件中通过locationMsg属性获取到位置信息了。</p><p>方式二使用方法结束。</p><p>我在实际运行中发现第二种使用方式会比第一种方式的耗时长一些，因此建议使用方式一实现。</p><p>本章全部内容结束，希望可以帮到你。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 百度地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无法连接GitHub完整解决方案</title>
      <link href="/2020/12/22/wu-fa-lian-jie-github-wan-zheng-jie-jue-fang-an/"/>
      <url>/2020/12/22/wu-fa-lian-jie-github-wan-zheng-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<ul><li>说明：我遇到的情况是Mac中无法连接GitHub（Chrome浏览器），不知道这篇文章能否对你的情况有所帮助。</li></ul><p>这两天突然发现GitHub连不上了，记不清是从什么时候开始的了，因为最近工作中去GitHub找资源的频率降低了些。</p><p>从昨天开始有需求连接GitHub连接不上，没在意，今天还是连不上。于是下劲解决了下，遂整理笔记如下，供大家参考。</p><h1 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h1><p>事故原因：经过我的探索，我最终发现我这边问题是出在 Ghelper 上，稍后详细叙述解决方案。</p><p><strong>在我解决完问题之后，发现目前连不上GitHub可能有以下两个原因：</strong></p><ol><li>浏览器插件的问题</li><li>hosts文件出现问题</li></ol><p>那到底怎么诊断是哪种问题呢？<br>很简单。</p><p>1，打开终端输入指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.github.com</span><br></pre></td></tr></table></figure><p>如果可以ping通，那基本上是上述原因的第一个（浏览器插件问题）。你也可以换浏览器验证到底是不是因为 Chrome 浏览器插件的问题。</p><p>2，如果上一步没有ping通，那么极有可能是上述原因中的第二个（hosts文件出现问题）。你可以找同事测试下，他如果可以正常连接 GitHub，九成就是这个 hosts 文件问题。</p><p>3，补充一下，还有可能是 GitHub 那边宕机了，或者网络问题。这个你可以找同事帮忙测试下，看看他可不可以连接 GitHub。</p><h1 id="相关解决方案如下"><a href="#相关解决方案如下" class="headerlink" title="相关解决方案如下"></a>相关解决方案如下</h1><h2 id="一，浏览器插件问题解决方案"><a href="#一，浏览器插件问题解决方案" class="headerlink" title="一，浏览器插件问题解决方案"></a>一，浏览器插件问题解决方案</h2><p>说明：这里说的浏览器插件是 Chrome 浏览器的 Ghelper 插件。因为我最终是确定这个插件的问题，所以我说的插件问题实际上说的是这个 Ghelper 插件。</p><p>步骤一：进入 Ghelper 的“控制面板”<br><img src="/myImg/github/lianjie/error1.png" class="lazyload placeholder" data-srcset="/myImg/github/lianjie/error1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Ghelper控制面板"></p><p>步骤二：剩下的内容，读下面这张图片就行了。</p><p>主要原因是，Ghelper 这个插件中内置了几个 github 的默认设置，就是这个默认设置，造成我的 Chrome 浏览器在安装了 Ghelper 之后无法连接 GitHub 的。所以我重新设置了这几个默认的 github 设置为直连方式。<br><img src="/myImg/github/lianjie/error2.png" class="lazyload placeholder" data-srcset="/myImg/github/lianjie/error2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Ghelper配置修改"></p><ul><li>PS：截图中“因为”两字错写成“应为”。</li></ul><p>步骤三：走完以上两步之后，就可以使用Chrome测试是否能够连接GitHub了。</p><p>本方案结束。</p><h2 id="二，hosts文件问题解决方案"><a href="#二，hosts文件问题解决方案" class="headerlink" title="二，hosts文件问题解决方案"></a>二，hosts文件问题解决方案</h2><h3 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h3><p>打开Finder（访达），然后快捷键：Command+Shift+g调出前往文件夹窗口。</p><p>输入：&#x2F;etc&#x2F;hosts，然后按回车</p><p>截图如下：<br><img src="/myImg/github/lianjie/error3.png" class="lazyload placeholder" data-srcset="/myImg/github/lianjie/error3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="前往文件夹"></p><h3 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h3><h4 id="1，将查找到的hosts文件拖出到桌面。"><a href="#1，将查找到的hosts文件拖出到桌面。" class="headerlink" title="1，将查找到的hosts文件拖出到桌面。"></a>1，将查找到的hosts文件拖出到桌面。</h4><p>拖到哪个地方都行，拖出来是因为接下来要编辑这个文件，然而原位置不允许编辑。但是，如果你是程序员，拥有各种编辑器的话，直接使用Sublime Text等编辑器直接编辑该文件也是可以的（保存的时候，输入电脑密码即可）。</p><h4 id="2，右键，使用“文本编辑”打开文档，然后，在后面拼接以下内容（内容较长，建议复制）："><a href="#2，右键，使用“文本编辑”打开文档，然后，在后面拼接以下内容（内容较长，建议复制）：" class="headerlink" title="2，右键，使用“文本编辑”打开文档，然后，在后面拼接以下内容（内容较长，建议复制）："></a>2，右键，使用“文本编辑”打开文档，然后，在后面拼接以下内容（内容较长，建议复制）：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://github.com 204.232.175.94 http://gist.github.com 107.21.116.220 http://help.github.com 207.97.227.252 http://nodeload.github.com 199.27.76.130 http://raw.github.com 107.22.3.110 http://status.github.com 204.232.175.78 http://training.github.com 207.97.227.243 http://www.github.com</span><br></pre></td></tr></table></figure><h4 id="3，保存"><a href="#3，保存" class="headerlink" title="3，保存"></a>3，保存</h4><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p>将步骤二，保存后的hosts文件，拖入到步骤一查找到的位置，替换文件。过程中需要输入电脑密码。</p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p>打开浏览器测试，不出意外的话，可以正常连接GitHub了。</p><p>本方案结束。</p><ul><li>PS：第二种方案（修改hosts文件内容这个方案）是一个终极解决方案。即使是Ghelper的默认设置问题，也可以通过修改该配置文件来解决（本人实测可行）。</li></ul><p>本章结束。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> git </tag>
            
            <tag> 连接 GitHub </tag>
            
            <tag> 无法连接 GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue跳转新页面后回到顶部</title>
      <link href="/2020/12/03/vue-tiao-zhuan-xin-ye-mian-hou-hui-dao-ding-bu/"/>
      <url>/2020/12/03/vue-tiao-zhuan-xin-ye-mian-hou-hui-dao-ding-bu/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue路由跳转之后页面置顶问题解决方案"><a href="#Vue路由跳转之后页面置顶问题解决方案" class="headerlink" title="Vue路由跳转之后页面置顶问题解决方案:"></a>Vue路由跳转之后页面置顶问题解决方案:</h2><p>全部页面的话就在router文件夹的index.js中设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach((to,from,next)=&gt;&#123;</span><br><span class="line">  window,scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>单独的某个页面就在页面加载之前设置</p><p>单独设置需变为this.$router</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="variable">$router</span>.afterEach((to,from,next)=&gt;&#123;</span><br><span class="line">  window,scrollTo(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>本章完。</p>]]></content>
      
      
      <categories>
          
          <category> Vue-Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue-Router跳转后置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router跳转页面后置顶问题</title>
      <link href="/2020/12/03/vue-router-tiao-zhuan-ye-mian-hou-zhi-ding-wen-ti/"/>
      <url>/2020/12/03/vue-router-tiao-zhuan-ye-mian-hou-zhi-ding-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-router跳转页面后置顶问题解决方法"><a href="#vue-router跳转页面后置顶问题解决方法" class="headerlink" title="vue-router跳转页面后置顶问题解决方法"></a>vue-router跳转页面后置顶问题解决方法</h2><p>在router文件夹的index.js文件中, 初始化 router 时设置如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 添加以下代码</span></span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to,<span class="keyword">from</span>,savedPosition</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(savedPosition)&#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上方法并不是一个完美的解决方案, 因为会有一个 bug: 点任意路由, 都会置顶. 一个组件的兄弟组件切换也会让页面置顶.</p><p>如果想要更完美的解决, 可参考另一篇博客: Vue跳转新页面后回到顶部</p>]]></content>
      
      
      <categories>
          
          <category> Vue-Router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue-Router </tag>
            
            <tag> Vue </tag>
            
            <tag> Vue-Router跳转后置顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统Mysql8数据库资源共享</title>
      <link href="/2020/12/01/mac-xi-tong-mysql8-shu-ju-ku-zi-yuan-gong-xiang/"/>
      <url>/2020/12/01/mac-xi-tong-mysql8-shu-ju-ku-zi-yuan-gong-xiang/</url>
      
        <content type="html"><![CDATA[<p>最近遇到了Mac中局域网下实现数据库资源共享的问题，百度了一波，没有直接了当的解决方案，在摸索了半天之后解决了实际困难。随即写篇博客，把那些弯弯绕捋直喽！</p><h2 id="1，查看-my-cnf-文件。注意，Mac中-MySQL的配置文件是-my-cnf-不是-my-ini。"><a href="#1，查看-my-cnf-文件。注意，Mac中-MySQL的配置文件是-my-cnf-不是-my-ini。" class="headerlink" title="1，查看 my.cnf 文件。注意，Mac中 MySQL的配置文件是 my.cnf 不是 my.ini。"></a>1，查看 my.cnf 文件。注意，Mac中 MySQL的配置文件是 my.cnf 不是 my.ini。</h2><p>终端中输入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --verbose --<span class="built_in">help</span> | grep my.cnf</span><br></pre></td></tr></table></figure><h2 id="2，查看-my-cnf-文件中的内容。继续输入以下指令："><a href="#2，查看-my-cnf-文件中的内容。继续输入以下指令：" class="headerlink" title="2，查看 my.cnf 文件中的内容。继续输入以下指令："></a>2，查看 my.cnf 文件中的内容。继续输入以下指令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /usr/local/etc/my.cnf</span><br></pre></td></tr></table></figure><p>执行截图如下：<br><img src="/myImg/mysql/mac/shujugongxiang/gx1.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="执行截图"></p><p>从终端输出结果中不难看出，MySQL 默认的连接地址是 127.0.0.1，我们想要允许在局域网中访问数据库的话，需要设置绑定地址为：0.0.0.0（即，任意地址均可连接）</p><h2 id="3，通过Finder（访达）前往-usr-local-etc-my-cnf-文件"><a href="#3，通过Finder（访达）前往-usr-local-etc-my-cnf-文件" class="headerlink" title="3，通过Finder（访达）前往 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf 文件"></a>3，通过Finder（访达）前往 &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf 文件</h2><p><img src="/myImg/mysql/mac/shujugongxiang/gx2.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="前往my.cnf文件-1"><br><img src="/myImg/mysql/mac/shujugongxiang/gx3.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="前往my.cnf文件-2"></p><h2 id="4，使用编辑器打开my-cnf文件发现默认设置如下："><a href="#4，使用编辑器打开my-cnf文件发现默认设置如下：" class="headerlink" title="4，使用编辑器打开my.cnf文件发现默认设置如下："></a>4，使用编辑器打开my.cnf文件发现默认设置如下：</h2><p><img src="/myImg/mysql/mac/shujugongxiang/gx4.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="my.cnf文件默认设置"></p><h2 id="5，修改bind-address-0-0-0-0，修改后代码如下："><a href="#5，修改bind-address-0-0-0-0，修改后代码如下：" class="headerlink" title="5，修改bind-address &#x3D; 0.0.0.0，修改后代码如下："></a>5，修改bind-address &#x3D; 0.0.0.0，修改后代码如下：</h2><p><img src="/myImg/mysql/mac/shujugongxiang/gx5.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="修改my.cnf文件设置"></p><h2 id="6，重启mysql服务。打开终端输入以下指令："><a href="#6，重启mysql服务。打开终端输入以下指令：" class="headerlink" title="6，重启mysql服务。打开终端输入以下指令："></a>6，重启mysql服务。打开终端输入以下指令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server restart</span><br></pre></td></tr></table></figure><p>执行效果如下：（想要再次通过终端查看 my.cnf 文件中的内容时，再次输入：cat &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf 指令即可）<br><img src="/myImg/mysql/mac/shujugongxiang/gx6.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/shujugongxiang/gx6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="重启mysql服务"></p><h2 id="7，接下来就可以愉快的玩耍了。"><a href="#7，接下来就可以愉快的玩耍了。" class="headerlink" title="7，接下来就可以愉快的玩耍了。"></a>7，接下来就可以愉快的玩耍了。</h2><p>可通过 Navicat 等连接测试下。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac 系统 </tag>
            
            <tag> MySQL8 </tag>
            
            <tag> MySQL8 数据库资源共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 系统 MySQL8 数据库资源共享</title>
      <link href="/2020/12/01/windows-xi-tong-mysql8-shu-ju-ku-zi-yuan-gong-xiang/"/>
      <url>/2020/12/01/windows-xi-tong-mysql8-shu-ju-ku-zi-yuan-gong-xiang/</url>
      
        <content type="html"><![CDATA[<p>​<br>最近遇到 MySQL 8 数据库资源共享的问题，百度一波答案之后，走了不少弯路, 然后决定写一篇博客给捋直喽！</p><p><strong>MySQL 版本：8.0.21</strong><br>如果因为版本不同，不能解决你的问题，请见谅！</p><h2 id="首先，登录自己的数据库，然后输入以下指令"><a href="#首先，登录自己的数据库，然后输入以下指令" class="headerlink" title="首先，登录自己的数据库，然后输入以下指令"></a>首先，登录自己的数据库，然后输入以下指令</h2><p>1，选择数据库, 输入终端指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure><p>2，添加数据库<strong>局域网访问权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user <span class="built_in">set</span> host = <span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果上面这行指令存在问题，可以使用下面这条，我在实际操作中使用的就是下面这条</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后，执行下面这样指令, <strong>目的是刷新权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>我的执行截图如下:<br><img src="/myImg/mysql/windows/shujugongxiang/gx1.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/shujugongxiang/gx1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="执行截图"></p><ul><li>注意：不要忘记以下两个设置</li></ul><ol><li><p>连接同一个局域网</p></li><li><p>关闭防火墙</p></li></ol><p><img src="/myImg/mysql/windows/shujugongxiang/gx2.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/shujugongxiang/gx2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="关闭防火墙"></p><p>接下来就可以通过 Navicat 等连接下测试测试了。<br>​</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL8 </tag>
            
            <tag> MySQL8 数据库资源共享 </tag>
            
            <tag> Windows 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中动态监听localStorage值的变动</title>
      <link href="/2020/05/25/vue-zhong-dong-tai-jian-ting-localstorage-zhi-de-bian-dong/"/>
      <url>/2020/05/25/vue-zhong-dong-tai-jian-ting-localstorage-zhi-de-bian-dong/</url>
      
        <content type="html"><![CDATA[<p>下面传送门中这篇博客中有个思路, 通过重写localStorage的setItem方法来实现实时更新<br>但是, 文章息乎不全, 记录下来, 以后有机会参考优化下.</p><p><a href="https://blog.csdn.net/weixin_43869192/article/details/85061248">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> localStorage </tag>
            
            <tag> vue中动态监听localStorage值的变动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue+Express搭建前后端分离项目</title>
      <link href="/2019/12/20/vue-express-da-jian-qian-hou-duan-fen-chi-xiang-mu/"/>
      <url>/2019/12/20/vue-express-da-jian-qian-hou-duan-fen-chi-xiang-mu/</url>
      
        <content type="html"><![CDATA[<h2 id="一，新建一个工程文件夹-——-myApp"><a href="#一，新建一个工程文件夹-——-myApp" class="headerlink" title="一，新建一个工程文件夹 —— myApp"></a>一，新建一个工程文件夹 —— myApp</h2><h2 id="二，在该工程中通过-Express-创建一个后端项目-——-myExpApp"><a href="#二，在该工程中通过-Express-创建一个后端项目-——-myExpApp" class="headerlink" title="二，在该工程中通过 Express 创建一个后端项目 —— myExpApp"></a>二，在该工程中通过 Express 创建一个后端项目 —— myExpApp</h2><h2 id="三，在该工程中通过-Vue-创建一个前端项目-——-myVueApp"><a href="#三，在该工程中通过-Vue-创建一个前端项目-——-myVueApp" class="headerlink" title="三，在该工程中通过 Vue 创建一个前端项目 —— myVueApp"></a>三，在该工程中通过 Vue 创建一个前端项目 —— myVueApp</h2><p>项目目录如下：</p><p>myApp<br>  |<br>  |—-myExpApp<br>  |—-myVueApp</p><h2 id="四，后台正常执行自己的项目"><a href="#四，后台正常执行自己的项目" class="headerlink" title="四，后台正常执行自己的项目"></a>四，后台正常执行自己的项目</h2><p>设置路由文件等等等。。。</p><h2 id="五，前端正常编写自己的Vue组件"><a href="#五，前端正常编写自己的Vue组件" class="headerlink" title="五，前端正常编写自己的Vue组件"></a>五，前端正常编写自己的Vue组件</h2><p>xxx.vue等等等。。。</p><h2 id="六，跨域问题"><a href="#六，跨域问题" class="headerlink" title="六，跨域问题"></a>六，跨域问题</h2><p>前端想要通过 ajax 请求后台数据，这是会有一个<strong>跨域问题</strong></p><p>因为前端的Vue项目运行使用的是 localhost:8080 端口、后台Express项目运行使用的是 localhost:3000 端口。</p><p>8080端口 来请求 3000端口 中的内容引起跨域问题。</p><p><strong>可通过以下步骤解决：</strong></p><h3 id="1、前端准备"><a href="#1、前端准备" class="headerlink" title="1、前端准备"></a>1、前端准备</h3><p><strong>使用axios模块发起ajax请求：</strong></p><p>在前端引入axios模块，前端工程myVueApp文件夹下执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>然后再 main.js 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://localhost:3000&quot;</span>;</span><br><span class="line">axios</span><br><span class="line">  .<span class="title function_">get</span>(url + <span class="string">&quot;/product&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>然后，前端先到此，现在不必执行，后台还没准备好。</p><h3 id="2、后台准备"><a href="#2、后台准备" class="headerlink" title="2、后台准备"></a>2、后台准备</h3><p>使用cors模块支持跨域</p><ul><li>注意：Node中支持跨域的方式有很多种，大家可以自行百度，这里使用的是比较简单的跨域支持方式。</li></ul><p>后台在 routers 文件夹中新建 product.js 文件，对前端的请求做支持。</p><p>product.js 文件中的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> dataMsg = &#123;</span><br><span class="line">    <span class="attr">code</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;白骨精&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;23&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&quot;请求成功&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">json</span>(dataMsg);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><p>然后在 app.js 文件中做如下配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/product&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/product&#x27;</span>, productRouter);</span><br></pre></td></tr></table></figure><p>再然后，为了支持跨域，引入cors模块，终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cors</span><br></pre></td></tr></table></figure><p>模块加载完毕之后，在 app.js 中引入并使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>()); </span><br></pre></td></tr></table></figure><p>app.js 中的所有操作，如下图所示：<br><img src="/myImg/vue/create/express.png" class="lazyload placeholder" data-srcset="/myImg/vue/create/express.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="app.js 配置"></p><p>大功告成！！！</p><p>接下来，执行你的前台、后台工程。<br>然后, 在浏览器中输入 localhost:8080 即可在控制台看到，product.js 文件返回的数据。<br>前后端就这么连通起来了。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows版MySQL使用总结</title>
      <link href="/2019/11/01/windows-ban-mysql-shi-yong-zong-jie/"/>
      <url>/2019/11/01/windows-ban-mysql-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>来吧, Windows 版的 MySQL​</p><h2 id="Windows-版-MySQL-使用总结"><a href="#Windows-版-MySQL-使用总结" class="headerlink" title="Windows 版 MySQL 使用总结"></a>Windows 版 MySQL 使用总结</h2><ul><li>注: MySQL 8.0.16版本</li></ul><h2 id="一-官网下载MySQL"><a href="#一-官网下载MySQL" class="headerlink" title="一, 官网下载MySQL"></a>一, 官网下载MySQL</h2><p><img src="/myImg/mysql/windows/anzhuang/az1.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="下载MySQL1"><br><img src="/myImg/mysql/windows/anzhuang/az2.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az2.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="下载MySQL2"><br><img src="/myImg/mysql/windows/anzhuang/az3.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="下载MySQL3"></p><h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二, 安装"></a>二, 安装</h2><p>直接解压缩到指定目录即可, 可以是C盘, 也可以是其他盘, 我安装在了E盘.</p><h2 id="三-安装完成之后-还需要完成以下配置"><a href="#三-安装完成之后-还需要完成以下配置" class="headerlink" title="三, 安装完成之后, 还需要完成以下配置."></a>三, 安装完成之后, 还需要完成以下配置.</h2><h3 id="1-在安装mysql的文件目录下创建data文件夹-同时新建my-ini文件-书写以下内容"><a href="#1-在安装mysql的文件目录下创建data文件夹-同时新建my-ini文件-书写以下内容" class="headerlink" title="1, 在安装mysql的文件目录下创建data文件夹, 同时新建my.ini文件, 书写以下内容"></a>1, 在安装mysql的文件目录下创建data文件夹, 同时新建my.ini文件, 书写以下内容</h3><p><img src="/myImg/mysql/windows/anzhuang/az4.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="新建my.ini文件"></p><p>my.ini文件中内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"># 设置3306端口</span><br><span class="line"></span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line"></span><br><span class="line">basedir=E:\MySQL\mysql-8.0.16-winx64</span><br><span class="line"></span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line"></span><br><span class="line">datadir=E:\MySQL\mysql-8.0.16-winx64\data</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line"></span><br><span class="line">max_connections=20</span><br><span class="line"></span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line"></span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line"></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line">#设置协议认证方式(重点啊) (默认使用“mysql_native_password”插件认证)</span><br><span class="line"></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"></span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line"></span><br><span class="line"># 设置mysql客户端连接服务端时默认使用的端口</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line"></span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><p><img src="/myImg/mysql/windows/anzhuang/az5.png" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="my.ini文件内容"></p><h3 id="2-配置-mysql"><a href="#2-配置-mysql" class="headerlink" title="2, 配置 mysql"></a>2, 配置 mysql</h3><p>然后通过<strong>管理员身份</strong>打开 cmd 输入以下指令, 注意一定是管理员身份打开cmd, 要不然会出各种问题.</p><p>以管理员身份打开 cmd 命令窗口,切换到 MySQL 的 bin 目录下执行以下命令：</p><ul><li>注意, 一定要以<strong>管理员身份</strong>打开cmd命令窗口</li></ul><ol><li><p>“mysqld –initialize –console”  回车   –&gt;初始化MySQL环境  ，此时会有一个初始密码，跟在root@localhost:之后,需要记住</p></li><li><p>“mysqld install” 回车   –&gt;安装mysql</p></li><li><p>“net start mysql”  回车   –&gt;启动MySQL服务器端</p></li><li><p>“mysql -u root -p”  回车   –&gt;让客户端连接到mysql,此时会让你输入密码，将上面给的密码复制粘贴</p></li><li><p>进入之后需要自己重新设置密码<br>    “ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘root123’;”</p></li></ol><ul><li>注意: 以上双引号中的才是要输入的终端指令</li></ul><h3 id="3-当忘记密码时"><a href="#3-当忘记密码时" class="headerlink" title="3, 当忘记密码时"></a>3, 当忘记密码时</h3><ol><li><p>删除data目录</p></li><li><p>重新运行上述 1-5 的步骤</p></li></ol><p>操作步骤图如下:</p><p><img src="/myImg/mysql/windows/anzhuang/az6.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az6.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="配置-1"><br><img src="/myImg/mysql/windows/anzhuang/az7.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az7.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="配置-2"></p><p>然后就可以正常使用数据库了<br><img src="/myImg/mysql/windows/anzhuang/az8.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az8.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="使用mysql-1"><br><img src="/myImg/mysql/windows/anzhuang/az9.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az9.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="使用mysql-2"></p><h2 id="四-如果在调用-net-时显示”net-不是内部指令”-去配置环境变量即可"><a href="#四-如果在调用-net-时显示”net-不是内部指令”-去配置环境变量即可" class="headerlink" title="四, 如果在调用 net 时显示”net 不是内部指令”, 去配置环境变量即可"></a>四, 如果在调用 net 时显示”net 不是内部指令”, 去配置环境变量即可</h2><p>“我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;系统环境变量-&gt;path” 找到path</p><h3 id="1-win7-环境变量配置"><a href="#1-win7-环境变量配置" class="headerlink" title="1, win7 环境变量配置"></a>1, win7 环境变量配置</h3><p>win 7 中选择”编辑”, 以分号间隔的形式, 在后面添加 C:\Windows\system32(因为cmd.exe的位置是在这里), 然后再添加mysql的bin文件夹的路径, 我的是在E盘, 位置如下, 以分号间隔, 添加即可 —- E:\MySQL\mysql-8.0.16-winx64\bin</p><p><img src="/myImg/mysql/windows/anzhuang/az10.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az10.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="win7 环境变量配置"></p><p>(Win7的这张截图是在另外一台电脑上截取的, 那里的mysql安装在D盘, 因此第6步中是D:\MySQL\mysql-8.0.16-winx64\bin)</p><h3 id="2-win10-环境变量配置"><a href="#2-win10-环境变量配置" class="headerlink" title="2, win10 环境变量配置"></a>2, win10 环境变量配置</h3><p>win10 中直接点击”新建”, 添加上述两条值即可. 如果已经存在其中之一,可以不必设置.</p><p><img src="/myImg/mysql/windows/anzhuang/az11.jpeg" class="lazyload placeholder" data-srcset="/myImg/mysql/windows/anzhuang/az11.jpeg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="win10 环境变量配置"></p><p>薛哥出品</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac软件安装 </tag>
            
            <tag> MySQL安装 </tag>
            
            <tag> Mac版MySQL使用总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac版MySQL使用总结</title>
      <link href="/2019/11/01/mac-ban-mysql-shi-yong-zong-jie/"/>
      <url>/2019/11/01/mac-ban-mysql-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>本篇文章重点讲述初次安装后的<strong>配置</strong></p><h2 id="Mac版MySQL使用总结"><a href="#Mac版MySQL使用总结" class="headerlink" title="Mac版MySQL使用总结:"></a>Mac版MySQL使用总结:</h2><ul><li>注: MySQL 8.0.16版本</li></ul><h2 id="一-安装-MySQL-两种方式"><a href="#一-安装-MySQL-两种方式" class="headerlink" title="一, 安装 MySQL. 两种方式:"></a>一, 安装 MySQL. 两种方式:</h2><p><strong>方式一:</strong> 直接去官网下载, 但是耗时较长</p><p><strong>方式二:</strong> 通过Homebrew安装, 安装速度比去官网下载快了N倍.</p><h2 id="二-初次安装完成之后-需要对MySQL进行配置-以下以Homebrew安装方式为例进行说明配置项"><a href="#二-初次安装完成之后-需要对MySQL进行配置-以下以Homebrew安装方式为例进行说明配置项" class="headerlink" title="二, 初次安装完成之后, 需要对MySQL进行配置, 以下以Homebrew安装方式为例进行说明配置项."></a>二, 初次安装完成之后, 需要对MySQL进行配置, 以下以Homebrew安装方式为例进行说明配置项.</h2><p><img src="/myImg/mysql/mac/anzhuang/az1.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/anzhuang/az1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="配置项"></p><h3 id="根据-提示-我们-输入-mysql-secure-installation-指令"><a href="#根据-提示-我们-输入-mysql-secure-installation-指令" class="headerlink" title="根据 提示 我们 输入 mysql_secure_installation 指令"></a>根据 提示 我们 输入 mysql_secure_installation 指令</h3><p>mysql_secure_installation会执行几个设置：</p><ul><li>为root用户设置密码</li><li>删除匿名账号</li><li>取消root用户远程登录</li><li>删除test库和对test库的访问权限</li><li>刷新授权表使修改生效</li></ul><p>通过这几项的设置能够提高 mysql 库的安全。</p><p>建议<strong>生产环境</strong>中 mysql 安装这完成后一定要运行一次 mysql_secure_installation，相关操作如下:<br><img src="/myImg/mysql/mac/anzhuang/az2.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/anzhuang/az2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行一次mysql_secure_installation"></p><h3 id="完成以上操作之后-我们需要输入-mysql-u-root-p-指令-通过新设置的密码进行登录"><a href="#完成以上操作之后-我们需要输入-mysql-u-root-p-指令-通过新设置的密码进行登录" class="headerlink" title="完成以上操作之后, 我们需要输入 : mysql -u root -p 指令,通过新设置的密码进行登录"></a>完成以上操作之后, 我们需要输入 : mysql -u root -p 指令,通过新设置的密码进行登录</h3><p><img src="/myImg/mysql/mac/anzhuang/az3.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/anzhuang/az3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="通过新设置的密码进行登录"></p><h3 id="然后-可以通过终端指令来操作数据库-辅助Node的连接"><a href="#然后-可以通过终端指令来操作数据库-辅助Node的连接" class="headerlink" title="然后, 可以通过终端指令来操作数据库, 辅助Node的连接"></a>然后, 可以通过终端指令来操作数据库, 辅助Node的连接</h3><p><img src="/myImg/mysql/mac/anzhuang/az4.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/anzhuang/az4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="通过终端指令来操作数据库"></p><h3 id="接下来就是Node中mysql模块发挥作用的时候了-就可以对数据库进行增、删、改、查了…"><a href="#接下来就是Node中mysql模块发挥作用的时候了-就可以对数据库进行增、删、改、查了…" class="headerlink" title="接下来就是Node中mysql模块发挥作用的时候了, 就可以对数据库进行增、删、改、查了…"></a>接下来就是Node中mysql模块发挥作用的时候了, 就可以对数据库进行增、删、改、查了…</h3><h3 id="当以后再次启动mysql时-按照以下步骤来做即可"><a href="#当以后再次启动mysql时-按照以下步骤来做即可" class="headerlink" title="当以后再次启动mysql时, 按照以下步骤来做即可."></a>当以后再次启动mysql时, 按照以下步骤来做即可.</h3><p><img src="/myImg/mysql/mac/anzhuang/az5.png" class="lazyload placeholder" data-srcset="/myImg/mysql/mac/anzhuang/az5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="再次启动mysql"></p><p>薛哥出品</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac软件安装 </tag>
            
            <tag> MySQL安装 </tag>
            
            <tag> Mac版MySQL使用总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs与CommonJS规范</title>
      <link href="/2019/10/13/nodejs-yu-commonjs-gui-fan/"/>
      <url>/2019/10/13/nodejs-yu-commonjs-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>​</p><h2 id="一，概述"><a href="#一，概述" class="headerlink" title="一，概述"></a>一，概述</h2><p>Node应用由模块组成，采用CommonJS模块规范。</p><p>根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</p><p>如果想在多个文件分享变量，必须定义为global对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">warning</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。</p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">x</span> = x;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">addX</span> = addX;</span><br></pre></td></tr></table></figure><p>上面代码通过module.exports输出变量x和函数addX。</p><p>require方法用于加载模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="property">x</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(example.<span class="title function_">addX</span>(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>CommonJS模块的特点如下:</p><ul><li>所有代码都运行在模块作用域，不会污染全局作用域。</li><li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li><li>模块加载的顺序，按照其在代码中出现的顺序。</li></ul><h2 id="二，module对象"><a href="#二，module对象" class="headerlink" title="二，module对象"></a>二，module对象</h2><p>Node内部提供一个Module构建函数。所有模块都是Module的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Module</span>(<span class="params">id, parent</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">exports</span> = &#123;&#125;;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parent</span> = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个模块内部，都有一个module对象，代表当前模块。它有以下属性:</p><ul><li>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</li><li>module.filename 模块的文件名，带有绝对路径。</li><li>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</li><li>module.parent 返回一个对象，表示调用该模块的模块。</li><li>module.children 返回一个数组，表示该模块要用到的其他模块。</li><li>module.exports 表示模块对外输出的值。</li></ul><p>下面是一个示例文件，最后一行输出module变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">$</span> = jquery;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">module</span>);</span><br></pre></td></tr></table></figure><p>执行这个文件，命令行会输出如下信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123; <span class="string">&#x27;$&#x27;</span>: [<span class="title class_">Function</span>] &#125;,</span><br><span class="line">  <span class="attr">parent</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;/path/to/example.js&#x27;</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">children</span>:</span><br><span class="line">   [ &#123; <span class="attr">id</span>: <span class="string">&#x27;/path/to/node_modules/jquery/dist/jquery.js&#x27;</span>,</span><br><span class="line">       <span class="attr">exports</span>: [<span class="title class_">Function</span>],</span><br><span class="line">       <span class="attr">parent</span>: [<span class="title class_">Circular</span>],</span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&#x27;/path/to/node_modules/jquery/dist/jquery.js&#x27;</span>,</span><br><span class="line">       <span class="attr">loaded</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">children</span>: [],</span><br><span class="line">       <span class="attr">paths</span>: [<span class="title class_">Object</span>] &#125; ],</span><br><span class="line">  <span class="attr">paths</span>:</span><br><span class="line">   [ <span class="string">&#x27;/home/user/deleted/node_modules&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;/home/user/node_modules&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;/home/node_modules&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;/node_modules&#x27;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在命令行下调用某个模块，比如node something.js，那么module.parent就是undefined。如果是在脚本之中调用，比如require(‘.&#x2F;something.js’)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="variable language_">module</span>.<span class="property">parent</span>) &#123;</span><br><span class="line">    <span class="comment">// ran with `node something.js`</span></span><br><span class="line">    app.<span class="title function_">listen</span>(<span class="number">8088</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;app listening on port 8088&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// used with `require(&#x27;/.something.js&#x27;)`</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-module-exports属性"><a href="#2-1-module-exports属性" class="headerlink" title="2.1 module.exports属性"></a>2.1 module.exports属性</h3><p>module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">EventEmitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>).<span class="property">EventEmitter</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span>.<span class="title function_">emit</span>(<span class="string">&#x27;ready&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line">a.<span class="title function_">on</span>(<span class="string">&#x27;ready&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;module a is ready&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-exports变量"><a href="#2-2-exports变量" class="headerlink" title="2.2 exports变量"></a>2.2 exports变量</h3><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span>;</span><br></pre></td></tr></table></figure><p>造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">area</span> = <span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">circumference</span> = <span class="keyword">function</span> (<span class="params">r</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x)&#125;;</span><br></pre></td></tr></table></figure><p>上面这样的写法是无效的，因为exports不再指向module.exports了。</p><p>下面的写法也是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">hello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。</p><p>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">x</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x);&#125;;</span><br></pre></td></tr></table></figure><p>如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。</p><h2 id="三，require命令"><a href="#三，require命令" class="headerlink" title="三，require命令"></a>三，require命令</h2><h3 id="3-1-基本用法"><a href="#3-1-基本用法" class="headerlink" title="3.1 基本用法"></a>3.1 基本用法</h3><p>Node使用CommonJS模块规范，内置的require命令用于加载模块文件。</p><p>require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> invisible = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;invisible&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">message</span> = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的命令，可以输出exports对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line">example</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   message: &quot;hi&quot;,</span></span><br><span class="line"><span class="comment">//   say: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./example2.js&#x27;</span>)()</span><br></pre></td></tr></table></figure><p>上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。</p><h3 id="3-2-加载规则"><a href="#3-2-加载规则" class="headerlink" title="3.2 加载规则"></a>3.2 加载规则</h3><p>require命令用于加载文件，后缀名默认为.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;foo.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>根据参数的不同格式，require命令去不同路径寻找模块文件。</p><p>（1）如果参数字符串以“&#x2F;”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘&#x2F;home&#x2F;marco&#x2F;foo.js’)将加载&#x2F;home&#x2F;marco&#x2F;foo.js。</p><p>（2）如果参数字符串以“.&#x2F;”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘.&#x2F;circle’)将加载当前脚本同一目录的circle.js。</p><p>（3）如果参数字符串不以“.&#x2F;“或”&#x2F;“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。</p><p>举例来说，脚本&#x2F;home&#x2F;user&#x2F;projects&#x2F;foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件:</p><ul><li>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node&#x2F;bar.js</li><li>&#x2F;home&#x2F;user&#x2F;projects&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;user&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;home&#x2F;node_modules&#x2F;bar.js</li><li>&#x2F;node_modules&#x2F;bar.js<br>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</li></ul><p>（4）如果参数字符串不以“.&#x2F;“或”&#x2F;“开头，而且是一个路径，比如require(‘example-module&#x2F;path&#x2F;to&#x2F;file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p><p>（5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p><p>（6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p><h3 id="3-3-目录的加载规则"><a href="#3-3-目录的加载规则" class="headerlink" title="3.3 目录的加载规则"></a>3.3 目录的加载规则</h3><p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。</p><p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;some-library&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span> : <span class="string">&quot;./lib/some-library.js&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。</p><h3 id="3-4-模块的缓存"><a href="#3-4-模块的缓存" class="headerlink" title="3.4 模块的缓存"></a>3.4 模块的缓存</h3><p>第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>).<span class="property">message</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./example.js&#x27;</span>).<span class="property">message</span></span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。</p><p>如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。</p><p>所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定模块的缓存</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[moduleName];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有模块的缓存</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="built_in">require</span>.<span class="property">cache</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">delete</span> <span class="built_in">require</span>.<span class="property">cache</span>[key];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。</p><h3 id="3-5-环境变量NODE-PATH"><a href="#3-5-环境变量NODE-PATH" class="headerlink" title="3.5 环境变量NODE_PATH"></a>3.5 环境变量NODE_PATH</h3><p>Node执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。</p><p>可以将NODE_PATH添加到.bashrc。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="variable constant_">NODE_PATH</span>=<span class="string">&quot;/usr/local/lib/node&quot;</span></span><br></pre></td></tr></table></figure><p>所以，如果遇到复杂的相对路径，比如下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;../../../../lib/myModule&#x27;</span>);</span><br></pre></td></tr></table></figure><p>有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;node_path&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;NODE_PATH=lib node index.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。</p><h3 id="3-6-模块的循环加载"><a href="#3-6-模块的循环加载" class="headerlink" title="3.6 模块的循环加载"></a>3.6 模块的循环加载</h3><p>如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">x</span> = <span class="string">&#x27;a1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">x</span> = <span class="string">&#x27;a2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">x</span> = <span class="string">&#x27;b1&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">x</span> = <span class="string">&#x27;b2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).<span class="property">x</span>);</span><br></pre></td></tr></table></figure><p>上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>修改main.js，再次加载a.js和b.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>).<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;main.js &#x27;</span>, <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>).<span class="property">x</span>);</span><br></pre></td></tr></table></figure><p>执行上面代码，结果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">b.js  a1</span><br><span class="line">a.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br><span class="line">main.js  a2</span><br><span class="line">main.js  b2</span><br></pre></td></tr></table></figure><p>上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。</p><h3 id="3-7-require-main"><a href="#3-7-require-main" class="headerlink" title="3.7 require.main"></a>3.7 require.main</h3><p>require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。</p><p>直接执行的时候（node module.js），require.main属性指向模块本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="property">main</span> === <span class="variable language_">module</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。</p><h2 id="四，模块的加载机制"><a href="#四，模块的加载机制" class="headerlink" title="四，模块的加载机制"></a>四，模块的加载机制</h2><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。</p><p>下面是一个模块文件lib.js。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。</p><p>然后，加载上面的模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">counter</span>;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).<span class="property">incCounter</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter);  <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。</p><h3 id="4-1-require的内部处理流程"><a href="#4-1-require的内部处理流程" class="headerlink" title="4.1 require的内部处理流程"></a>4.1 require的内部处理流程</h3><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property">_load</span> = <span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 检查 Module._cache，是否缓存之中有指定模块</span></span><br><span class="line">  <span class="comment">// 2. 如果缓存之中没有，就创建一个新的Module实例</span></span><br><span class="line">  <span class="comment">// 3. 将它保存到缓存</span></span><br><span class="line">  <span class="comment">// 4. 使用 module.load() 加载指定的模块文件，</span></span><br><span class="line">  <span class="comment">//    读取文件内容之后，使用 module.compile() 执行文件代码</span></span><br><span class="line">  <span class="comment">// 5. 如果加载/解析过程报错，就从缓存删除该模块</span></span><br><span class="line">  <span class="comment">// 6. 返回该模块的 module.exports</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Module</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_compile</span> = <span class="keyword">function</span>(<span class="params">content, filename</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 生成一个require函数，指向module.require</span></span><br><span class="line">  <span class="comment">// 2. 加载其他辅助方法到require</span></span><br><span class="line">  <span class="comment">// 3. 将文件内容放到一个函数之中，该函数可调用 require</span></span><br><span class="line">  <span class="comment">// 4. 执行该函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第1步和第2步，require函数及其辅助方法主要如下:</p><ul><li>require(): 加载外部模块</li><li>require.resolve()：将模块名解析到一个绝对路径</li><li>require.main：指向主模块</li><li>require.cache：指向所有缓存的模块</li><li>require.extensions：根据文件的后缀名，调用不同的执行函数</li></ul><p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;</span><br><span class="line">  <span class="comment">// YOUR CODE INJECTED HERE!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p><h2 id="五，参考链接"><a href="#五，参考链接" class="headerlink" title="五，参考链接"></a>五，参考链接</h2><p>来自<a href="https://javascript.ruanyifeng.com/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言规范 </tag>
            
            <tag> Nodejs </tag>
            
            <tag> CommonJS规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS规范、AMD规范和CMD规范的区别</title>
      <link href="/2019/10/13/commonjs-gui-fan-amd-gui-fan-he-cmd-gui-fan-de-qu-bie/"/>
      <url>/2019/10/13/commonjs-gui-fan-amd-gui-fan-he-cmd-gui-fan-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>首先，CommonJS规范的特点：</p><ul><li>对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值。</li><li>对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。</li><li>当使用require命令加载某个模块时，就会运行整个模块的代码。</li><li>当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li><li>循环加载时，属于加载时执行。即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul><h2 id="一，CommonJS与AMD："><a href="#一，CommonJS与AMD：" class="headerlink" title="一，CommonJS与AMD："></a>一，CommonJS与AMD：</h2><p>CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。</p><p>AMD规范则是非同步加载模块，允许指定回调函数。</p><p>由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。</p><h2 id="二，CMD和AMD："><a href="#二，CMD和AMD：" class="headerlink" title="二，CMD和AMD："></a>二，CMD和AMD：</h2><p>1.对于依赖的模块 AMD 是<strong>提前执行</strong>，CMD 是<strong>延迟执行</strong>。不过 RequireJS 从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</p><p>2.AMD推崇<strong>依赖前置</strong>（在定义模块的时候就要声明其依赖的模块），CMD推崇<strong>依赖就近</strong>（只有在用到某个模块的时候再去require——按需加载）。</p><p>3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。</p><h2 id="三，拓展阅读："><a href="#三，拓展阅读：" class="headerlink" title="三，拓展阅读："></a>三，拓展阅读：</h2><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出，CMD是SeaJS 在推广过程中被广泛认知。RequireJs出自dojo加载器的作者James Burke，SeaJs出自国内前端大师玉伯。二者的区别，玉伯在12年<a href="https://www.zhihu.com/question/20342350/answer/14828786">如是说</a>：</p><p>RequireJS 和 SeaJS 都是很不错的模块加载器，两者区别如下：</p><ol><li><p>两者定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino &#x2F; Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端</p></li><li><p>两者遵循的标准有差异。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules&#x2F;1.1 和 Node Modules 规范。</p></li><li><p>两者社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，而采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</p></li><li><p>两者代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。</p></li><li><p>两者对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便便捷。RequireJS无这方面的支持。</p></li><li><p>两者的插件机制有差异。RequireJS 采取的是在源码中预留接口的形式，源码中留有为插件而写的代码。SeaJS 采取的插件机制则与 Node 的方式一致开放自身，让插件开发者可直接访问或修改，从而非常灵活，可以实现各种类型的插件。</p></li></ol><p><strong>优点：</strong> 同样实现了浏览器端的模块化加载。 可以按需加载，依赖就近。</p><p><strong>缺点：</strong> 依赖SPM打包，模块的加载逻辑偏重。</p><p>本章完！</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言规范 </tag>
            
            <tag> CMD规范 </tag>
            
            <tag> Nodejs </tag>
            
            <tag> AMD规范 </tag>
            
            <tag> CommonJS规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD规范</title>
      <link href="/2019/10/13/cmd-gui-fan/"/>
      <url>/2019/10/13/cmd-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>在学习AMD规范的过程中，顺带学习了CMD规范，随分享如下：</p><h2 id="一，CMD简介"><a href="#一，CMD简介" class="headerlink" title="一，CMD简介"></a>一，CMD简介</h2><p><strong>CMD(Common Module Definition)</strong> ，通用模块定义。CMD是SeaJS 在推广过程中对模块定义的规范化产出。因此与AMD类似的，在使用CMD时，也需要引入第三方的库文件 —- SeaJS。</p><p><strong>SeaJS也是主要解决两个问题：</strong></p><ol><li>多个JS文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>JS加载的时候，浏览器会停止渲染页面，加载文件越多，浏览器失去响应时间越长。</li></ol><p>通过上述特点，不难看出 CMD 与 AMD 非常相似，只不过在 <strong>模块定义方式</strong> 和 <strong>模块加载时机</strong> 上两者存在不同。</p><h2 id="二，CMD模块的定义"><a href="#二，CMD模块的定义" class="headerlink" title="二，CMD模块的定义"></a>二，CMD模块的定义</h2><p>在 CMD 规范中，<strong>一个模块就是一个文件</strong>。代码的书写格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory);</span><br></pre></td></tr></table></figure><p>define是一个全局函数，用来定义一个模块。接下来会有对参数factory的详细介绍。</p><p>另外，与define相关的一个属性cmd。</p><p>define.cmd：一个空对象，可用来判定当前页面是否有 CMD 模块加载器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof define === &quot;function&quot; &amp;&amp; define.cmd) &#123;</span><br><span class="line">  // 有 Sea.js 等 CMD 模块加载器存在时</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三，factory参数"><a href="#三，factory参数" class="headerlink" title="三，factory参数"></a>三，factory参数</h2><p>factory：可以是一个函数，也可以是一个对象或字符串。</p><h3 id="1，factory-为对象、字符串时：表示模块的接口就是该对象、字符串。"><a href="#1，factory-为对象、字符串时：表示模块的接口就是该对象、字符串。" class="headerlink" title="1，factory 为对象、字符串时：表示模块的接口就是该对象、字符串。"></a>1，factory 为对象、字符串时：表示模块的接口就是该对象、字符串。</h3><p>比如可以如下定义一个 JSON 数据模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;&quot;uName&quot;:&quot;xdl&quot;&#125;);//factory是对象</span><br><span class="line"></span><br><span class="line">define(&#x27;Hello world,my name is &#123;&#123;name&#125;&#125;.&#x27;);    //factory是字符串</span><br></pre></td></tr></table></figure><h3 id="2，factory-为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。"><a href="#2，factory-为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。" class="headerlink" title="2，factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。"></a>2，factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。</h3><p>方法在执行时，默认会传入三个参数：<strong>require</strong>、<strong>exports</strong>、<strong>module</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // 模块代码</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面是这三个参数的具体介绍：</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 参数一：require 参数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>require：它是一个方法（函数）。他接收 <strong>模块标识</strong> 作为唯一参数，用来接受其他模块的接口。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line"></span><br><span class="line">    var aM = require(&#x27;./aM&#x27;); // 引入aM模块，这里是相对路径</span><br><span class="line"></span><br><span class="line">    aM.doSomething(); // 使用aM模块中的方法</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：在开发时，require 的书写要遵循以下规则：</p><ol><li>正确拼写。一定要正确拼写require，错误的拼写都是无效的。</li><li>不要修改。不能对require进行重新赋值和重命名。</li><li>使用直接量。即，require的参数必须是字符串的直接量，不能使用字符串拼接等模式。</li></ol><p>与require参数相关的两个方法：<strong>async、resolve</strong></p><p><strong>i，require.async</strong></p><p>require.async(id[, callback?]) 方法的作用是：用来在模块内部异步加载模块，并在加载完成后执行指定回调。一般用来加载可延迟异步加载的模块。</p><p>callback 参数，可选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // 异步加载一个模块，在加载完成时，执行回调</span><br><span class="line">  require.async(&#x27;./aModule&#x27;, function(aModule) &#123;</span><br><span class="line">    aModule.doSomething();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 异步加载多个模块，在加载完成时，执行回调</span><br><span class="line">  require.async([&#x27;./bModule&#x27;, &#x27;./cModule&#x27;], function(bModule, cModule) &#123;</span><br><span class="line">    bModule.doSomething();</span><br><span class="line">    cModule.doSomething();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：require是同步往下执行；require.async是异步回调执行。</p><p><strong>ii，require.resolve</strong></p><p>require.resolve(id) 方法的作用是：使用模块系统内部的路径解析机制来解析并返回模块路径。一般用在插件环境或需动态拼接模块路径的场景下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports) &#123;</span><br><span class="line">    // 获取 bModule 模块的绝对路径</span><br><span class="line">    console.log(require.resolve(&#x27;./bModule&#x27;)); // ==&gt; http://www.xxx.com/home/path/bModule.js</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：该函数不会加载模块，只返回解析后的绝对路径。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 参数二：exports 参数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>exports：它是一个对象。用来向外提供模块接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports) &#123;</span><br><span class="line"></span><br><span class="line">  // 对外提供 uName 属性</span><br><span class="line">  exports.uName = &#x27;xdl&#x27;;</span><br><span class="line"></span><br><span class="line">  // 对外提供 doSomething 方法</span><br><span class="line">  exports.doSomething = function() &#123;</span><br><span class="line">    console.log(&#x27;Hello world!&#x27;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外，还可以通过return直接返回当前模块的接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define(function(require) &#123;</span><br><span class="line"></span><br><span class="line">  // 通过 return 直接提供接口</span><br><span class="line">  return &#123;</span><br><span class="line">    uName: &#x27;xdl&#x27;,</span><br><span class="line">    doSomething: function() &#123;</span><br><span class="line">        console.log(&#x27;Hello world&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此外，如果return语句是当前模块的唯一代码，以上程序可以简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    uName: &#x27;xdl&#x27;,</span><br><span class="line">    doSomething: function() &#123;</span><br><span class="line">        console.log(&#x27;Hello world&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>诶！这不就是个JSONP格式数据模块吗？^_^</p><p><strong>本质上：exports</strong> 仅仅是 第三个参数 <strong>module</strong> 的 exports 属性的一个引用。</p><p>因此，在 factory 函数内部我们一般不会给这个参数 <strong>exports参数</strong> 重新赋值。</p><p>即使赋值也会无效，甚至出错。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports) &#123;</span><br><span class="line"></span><br><span class="line">  // 错误用法！！!</span><br><span class="line">  exports = &#123;</span><br><span class="line">    uName: &#x27;xdl&#x27;,</span><br><span class="line">    doSomething: function() &#123;</span><br><span class="line">        console.log(&#x27;Hello world&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果非要给 exports 赋值，可以通过以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    </span><br><span class="line">    // 正确用法</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">        uName: &#x27;xdl&#x27;,</span><br><span class="line">        doSomething: function() &#123;</span><br><span class="line">            console.log(&#x27;Hello world!&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 参数三：module 参数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>module：是一个对象，上面存储了与当前模块相关联的一些属性和方法。<br>module 的几个常用属性、方法如下：</p><p><strong>I. module.id：模块的唯一标识</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(&#x27;oneModule&#x27;, [], function(require, exports, module) &#123;</span><br><span class="line">  console.log(module.id);// oneModule</span><br><span class="line"></span><br><span class="line">  // 模块代码</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，oneModule就是当前模块的唯一标识。</p><p>注：以上define定义模块的格式是：define(id, deps, factory)。这种用法实际上不属于CMD规范，而属于 Modules&#x2F;Transport 规范。</p><p><strong>II. module.uri：根据模块系统的路径解析规则得到的模块绝对路径。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  console.log(module.uri);// ==&gt; http://www.xxx.com/home/path/this/xxx.js</span><br><span class="line">  console.log(module.id);// ==&gt; http://www.xxx.com/home/path/this/xxx.js</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注：通过 define(factory) 格式创建的模块内部，module.id 和 module.uri 两者完全相同。</p><p><strong>III. module.dependencies：是一个数组，表示当前模块的依赖。</strong></p><p><strong>IV. module.exports：是一个对象，当前模块对外提供的接口。</strong></p><p>传给 factory 构造函数的 exports 参数，是 module.exports 对象的一个引用。通过 exports 参数可以很方便的为当前模块的输出对象添加属性和方法。但是，只通过 exports 参数来提供接口，有时无法满足我们的所有需求，因此 factory 构造函数预留了这个 module 参数，通过修改 module 参数的 exports 属性，能够让我们实现更多的对于输出对象的设置。</p><p>例如：修改当前模块对外提供的接口为某一对象的实例时，需要通过 module.exports 来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line"></span><br><span class="line">  // exports 是 module.exports 的一个引用</span><br><span class="line">  console.log(module.exports === exports); // true</span><br><span class="line"></span><br><span class="line">  // 重新给 module.exports 赋值为 XXXCLass 类的一个实例</span><br><span class="line">  module.exports = new XXXClass();</span><br><span class="line"></span><br><span class="line">  // exports 不再等于 module.exports</span><br><span class="line">  console.log(module.exports === exports); // false</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="四，总结"><a href="#四，总结" class="headerlink" title="四，总结"></a>四，总结</h2><p>与之前介绍的 AMD 规范相比，CMD 规范在尽量保持简单同时，能够与 CommonJS 和 Node.js 的 Modules 规范保持很强的兼容性。</p><p>通过 CMD 规范书写的模块，可以很容易在 Node.js 中运行。</p><h2 id="五，下集预告"><a href="#五，下集预告" class="headerlink" title="五，下集预告"></a>五，下集预告</h2><p>CommonJS规范、AMD规范和CMD规范的区别</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言规范 </tag>
            
            <tag> CMD </tag>
            
            <tag> CMD规范 </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AMD规范</title>
      <link href="/2019/10/13/amd-gui-fan/"/>
      <url>/2019/10/13/amd-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>在读某第三方的源代码时，发现一个 <strong>define()</strong> 方法，随即开始了<strong>AMD</strong>语法的学习，随将学习成果分享如下：</p><h2 id="一，ADM规范背景调查"><a href="#一，ADM规范背景调查" class="headerlink" title="一，ADM规范背景调查"></a>一，ADM规范背景调查</h2><p>前端技术在不断的发展之中，很多公司会开发自己的框架来用。开发一个自己会用的框架并不难，但开发一个大家都喜欢的框架却很难。从一个框架迁移到一个新的框架，开发者很有可能还会按照原有框架的思维去思考和解决问题。这其中的一个重要原因就是JavaScript本身的灵活性：框架没办法绝对的约束你的行为，一件事情总可以用多种途径去实现，所以我们只能在方法学上去引导正确的实施方法。</p><p>庆幸的是，在这个层面上的软件方法学研究，一直有人在去不断的尝试和改进，CommonJS就是其中的一个重要组织。他们提出了许多新的JavaScript架构方案和标准，希望能为前端开发提供引导，提供统一的指引。</p><p>AMD规范也其中比较著名一个。AMD规范，全称是Asynchronous Module Definition，即<strong>异步模块加载机制</strong>。从它的规范描述页面看，AMD很短也很简单，但它却完整描述了模块的定义，依赖关系，引用关系以及加载机制。从它被requireJS，NodeJs，Dojo，JQuery使用也可以看出它具有很大的价值，没错，JQuery近期也采用了AMD规范。</p><p>AMD规范是RequireJS在推广过程中对模块定义的规范化产出。</p><p>AMD规范主要用于浏览器，由于该规范不是原生JS支持的，使用AMD规范进行开发时，需要引入第三方函数库，即RequireJS</p><h3 id="RequireJS主要解决两个问题："><a href="#RequireJS主要解决两个问题：" class="headerlink" title="RequireJS主要解决两个问题："></a>RequireJS主要解决两个问题：</h3><ol><li>多个JS文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>JS加载的时候，浏览器会停止渲染页面，加载文件越多，浏览器失去响应时间越长。</li></ol><h3 id="来个简单的插曲-—-RequireJS"><a href="#来个简单的插曲-—-RequireJS" class="headerlink" title="来个简单的插曲 —- RequireJS"></a>来个简单的插曲 —- RequireJS</h3><p><strong>1，RequireJS中定义模块 —- 通过 define() 函数定义模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([module-name], [array-of-dependencies?], module-factory-or-object)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>module-name: 模块标识，字符串类型，<strong>可选值</strong>。如果没有提供参数，默认为文件名。</li><li>array-of-dependencies: 所依赖的模块，字符串数组，<strong>可选值</strong>。</li><li>module-factory-or-object: 模块的具体实现本身，初始化模块需要执行的函数或者一个JavaScript对象，<strong>必需</strong>。如果是函数，它只执行一次；如果是对象，此对象会作为模块的输出值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// module1</span><br><span class="line">define(&#x27;module1&#x27;, function() &#123;</span><br><span class="line">// ...</span><br><span class="line">return &#123;</span><br><span class="line">add: function() &#123;</span><br><span class="line">return ...;</span><br><span class="line">&#125;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// module2</span><br><span class="line">define(&#x27;module2&#x27;,[&#x27;module1&#x27;] function(module1) &#123;</span><br><span class="line">// 使用module1模块中的方法</span><br><span class="line">module1.add();</span><br><span class="line">// ...</span><br><span class="line">return &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>2，加载模块</strong></p><p>模块的加载使用require()函数 —- <strong>异步加载模块</strong>，这样浏览器不会失去响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require([dependencies], function)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>dependencies：字符串数组，该模块的依赖。</li><li>function：Function类型，所依赖的模块都加载成功之后回调。依赖的模块会以参数的形式传入该函数，从而在回调函数内部就可以使用这些模块。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>RequireJS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>RequireJS学习<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;require.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">require</span>([<span class="string">&#x27;module1&#x27;</span>,<span class="string">&#x27;module2&#x27;</span>],<span class="keyword">function</span>(<span class="params">module1, module2</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好，插曲就到这里了，接下来言归正传。</p><h2 id="二，ADM规范具体实现"><a href="#二，ADM规范具体实现" class="headerlink" title="二，ADM规范具体实现"></a>二，ADM规范具体实现</h2><p>AMD规范简单到只有一个API，即define函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([module-name?], [array-of-dependencies?], module-factory-or-object);</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>module-name: 模块标识，字符串类型，可选值。如果没有提供参数，默认为文件名。</li><li>array-of-dependencies: 所依赖的模块，字符串数组，可选值。AMD推崇依赖前置，即当前模块依赖的其他模块，模块依赖必须在真正执行具体的module-factory-or-object方法之前解决。</li><li>module-factory-or-object: 模块的具体实现本身，初始化模块需要执行的函数或者一个JavaScript对象，必需。如果是函数，它只执行一次；如果是对象，此对象会作为模块的输出值。</li></ul><p><strong>当define函数执行时</strong>：它首先会异步的去调用第二个参数中列出的依赖模块，当所有的模块被载入完成之后，如果第三个参数是一个回调函数则执行，然后告诉系统模块可用，也就通知了依赖于自己的模块自己已经可用。</p><h2 id="三，AMD示例：如何定义一个模块"><a href="#三，AMD示例：如何定义一个模块" class="headerlink" title="三，AMD示例：如何定义一个模块"></a>三，AMD示例：如何定义一个模块</h2><p>下面代码定义了一个alpha模块，并且依赖于内置的require，exports模块，以及外部的beta模块。可以看到，第三个参数是回调函数，可以直接使用依赖的模块，他们按依赖声明顺序作为参数提供给回调函数。</p><p>这里的require函数让你能够随时去依赖一个模块，即取得模块的引用，从而即使模块没有作为参数定义，也能够被使用；exports是定义的alpha 模块的实体，在其上定义的任何属性和方法也就是alpha模块的属性和方法。通过exports.verb &#x3D; …就是为alpha模块定义了一个verb方法。例子中是简单调用了模块beta的verb方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(“alpha”, [“require”, “exports”, “beta”], function (require, exports, beta) &#123;</span><br><span class="line"></span><br><span class="line">    exports.verb = function() &#123;</span><br><span class="line"></span><br><span class="line">        return beta.verb();</span><br><span class="line"></span><br><span class="line">        //或者:</span><br><span class="line"></span><br><span class="line">        return require(“beta”).verb();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="四，匿名模块"><a href="#四，匿名模块" class="headerlink" title="四，匿名模块"></a>四，匿名模块</h2><p>define 方法允许你省略第一个参数，这样就定义了一个匿名模块，这时候模块文件的文件名就是模块标识。如果这个模块文件放在a.js中，那么a就是模块名。可以在依赖项中用”a”来依赖于这个匿名模块。这带来一个好处，就是模块是高度可重用的。你拿来一个匿名模块，随便放在一个位置就可以使用它，模块名就是它的文件路径。这也很好的符合了DRY（Don’t Repeat Yourself）原则。</p><p>下面的代码就定义了一个依赖于alpha模块的匿名模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define([“alpha”], function (alpha) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        verb: function()&#123;</span><br><span class="line">            return alpha.verb() + 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五，仅有一个参数的define"><a href="#五，仅有一个参数的define" class="headerlink" title="五，仅有一个参数的define"></a>五，仅有一个参数的define</h2><p>前面提到，define的前两个参数都是可以省略的。</p><p>第三个参数有两种情况，一种是一个JavaScript对象，另一种是一个函数。</p><h3 id="1，第三个参数为对象"><a href="#1，第三个参数为对象" class="headerlink" title="1，第三个参数为对象"></a>1，第三个参数为对象</h3><p>如果是一个对象，那么它可能是一个包含方法具有功能的一个对象；也有可能是仅提供数据。后者和JSON-P非常类似，因此AMD也可以认为包含了一个完整的 JSON-P实现。模块演变为一个简单的数据对象，这样的数据对象是高度可用的，而且因为是静态对象，它也是CDN友好的，可以提高JSON-P的性能。考虑一个提供中国省市对应关系的JavaScript对象，如果以传统JSON-P的形式提供给客户端，它必须提供一个callback函数名，根据这个函数名动态生成返回数据，这使得标准JSON-P数据一定不是CDN友好的。但如果用AMD，这个数据文件就是如下的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">    provinces: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: ‘上海’,</span><br><span class="line">            areas: [‘浦东新区’, ‘徐汇区’]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            name: ‘江苏’,</span><br><span class="line">            cities: [‘南京’, ‘南通’]</span><br><span class="line">        &#125;，</span><br><span class="line">        // ......</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>假设这个文件名为china.js，那么如果某个模块需要这个数据，只需要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([‘china’, function(china)&#123;</span><br><span class="line">    //在这里使用中国省市数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这种方式，这个模块是真正高度可复用的，无论是用远程的，还是Copy到本地项目，都节约了开发时间和维护时间。</p><h3 id="2，第三个参数为函数"><a href="#2，第三个参数为函数" class="headerlink" title="2，第三个参数为函数"></a>2，第三个参数为函数</h3><p>如果参数是一个函数，其用途之一是快速开发实现。适用于较小型的应用，你无需提前关注自己需要什么模块，自己给谁用。在函数中，可以随时require自己需要的模块。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(function()&#123;</span><br><span class="line">    var p = require(‘china’);</span><br><span class="line">    //使用china这个模块</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即你省略了模块名，以及自己需要依赖的模块。这不意味着你无需依赖于其他模块，而是可以让你在需要的时候去require这些模块。define方法在执行的时候，会调用函数的toString方法，并扫描其中的require调用，提前帮助你载入这些模块，载入完成之后再执行。这使得快速开发成为可能。需要注意的一点是，Opera浏览器不能很好的支持函数的toString方法，因此，在浏览器中它的适用性并不是很强。但如果你是通过build工具打包所有的 JavaScript文件，这将不是问题，构建工具会帮助你扫描require并强制载入依赖的模块。</p><h2 id="六，结论"><a href="#六，结论" class="headerlink" title="六，结论"></a>六，结论</h2><p>AMD 规范是JavaScript开发的一次重要尝试，它以简单而优雅的方式统一了JavaScript的模块定义和加载机制，并迅速得到很多框架的认可和采纳。这对开发人员来说是一个好消息，通过AMD我们降低了学习和使用各种框架的门槛，能够以一种统一的方式去定义和使用模块，提高开发效率，降低了应用维护成本。</p><h2 id="七，下集预告"><a href="#七，下集预告" class="headerlink" title="七，下集预告"></a>七，下集预告</h2><p>CMD规范</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言规范 </tag>
            
            <tag> Nodejs </tag>
            
            <tag> AMD </tag>
            
            <tag> AMD规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS规范</title>
      <link href="/2019/10/13/commonjs-gui-fan/"/>
      <url>/2019/10/13/commonjs-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>​</p><h3 id="今天来聊一聊-CommonJS-语法规范。"><a href="#今天来聊一聊-CommonJS-语法规范。" class="headerlink" title="今天来聊一聊 CommonJS 语法规范。"></a>今天来聊一聊 CommonJS 语法规范。</h3><p>对于 CommonJS 语法规范，当前官网提供三个版本文档的介绍：1.0、1.1、1.1.1</p><p>这里着重介绍 <strong>1.0</strong> 和 <strong>1.1</strong> 版本的模块（modules）规范。</p><h2 id="一，CommonJS-1-0-模块规范"><a href="#一，CommonJS-1-0-模块规范" class="headerlink" title="一，CommonJS 1.0 模块规范"></a>一，CommonJS 1.0 模块规范</h2><p>状态：<strong>MULTIPLE IMPLEMENTATIONS</strong>（被1.1替代）</p><p>简介：该规范解决了应该如何编写模块，以便在一类模块系统之间实现互操作，这些模块系统既可以是客户端也可以是服务器端，无论是安全的还是不安全的，都可以在今天实施，或者由具有语法扩展功能的未来系统所支持。这些模块具有最大范围的私密性，可以从其他模块导入单例对象并导出自己的API。隐含地，本规范定义了模块系统必须提供的最小功能，以支持可互操作的模块。</p><p><strong>简言之</strong>：根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p><p><strong>CommonJS中的几个基本概念</strong></p><h3 id="模块上下文："><a href="#模块上下文：" class="headerlink" title="模块上下文："></a>模块上下文：</h3><ol><li>在一个模块中，存在一个自由变量“<strong>require</strong>”函数<br>  (1). 这个“rquire”函数接收一个<em>模块标识符（解释如下“模块标识符”项）</em>。<br>  (2). “rquire”返回外部模块所输出的 API。<br>  (3). 如果出现依赖闭环(dependency cycle)，那么外部模块在被它的传递依赖(transitive dependencies)所require的时候可能并没有执行完成，这种情况下“require“返回的对象必须至少包含此外部模块在调用require函数之前就已经准备完毕的输出。<br>  (4). 如果请求模块不能返回，那么”require“必须抛出一个错误。</li><li>在一个模块中，存在一个名为”<strong>exports</strong>“的自由变量，它是一个对象，模块可以在执行的时候把自身 API 加入到其中。</li><li>模块必须使用<strong>exports</strong>对象来作为输出的唯一表示。</li></ol><h3 id="模块标识符："><a href="#模块标识符：" class="headerlink" title="模块标识符："></a>模块标识符：</h3><ol><li>模块标示符是一个由正斜杠分隔的”<strong>terms</strong>“组成的字符串。</li><li>一个<strong>terms</strong>的必须为驼峰样式标识符，或者为 “.” 或 “..”。</li><li>模块标识符可以省略文件名的后缀。比如”<strong>.js</strong>“。</li><li>模块标识符可以是相对路径(relative)或者绝对路径(top-level)。如果模块标识符的开头是 “.” 或者 “..” 则此模块标识符为相对路径。</li><li>绝对路径必须是模块所在命名空间的根。</li><li>相对路径必须是相对于当前 <strong>require</strong> 的模块。</li></ol><p>示例代码：</p><p>math.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exports.add = function() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>increment.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var add = require(&#x27;math&#x27;).add;</span><br><span class="line">exports.increment = function(val) &#123;</span><br><span class="line">    return add(val, 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>program.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var inc = require(&#x27;increment&#x27;).increment;</span><br><span class="line">var a = 1;</span><br><span class="line">inc(a); // 2</span><br></pre></td></tr></table></figure><h2 id="二，CommonJS-1-1-模块规范"><a href="#二，CommonJS-1-1-模块规范" class="headerlink" title="二，CommonJS 1.1 模块规范"></a>二，CommonJS 1.1 模块规范</h2><p>状态：<strong>MULTIPLE IMPLEMENTATIONS</strong>（广泛运用）</p><p><strong>CommonJS 1.1</strong> 与 <strong>1.0</strong> 相比主要在 模块上下文(Module Context)部分增加了一些规范。</p><p>对于CommonJS 1.1规范有以下定义。</p><h3 id="模块上下文：-1"><a href="#模块上下文：-1" class="headerlink" title="模块上下文："></a>模块上下文：</h3><ol><li>在一个模块中，存在一个自由变量“require”函数。<br>  (1). 这个“rquire”函数接收一个模块标识符。<br>  (2). “rquire”返回外部模块所输出的API。<br>  (3). 如果出现依赖闭环(dependency cycle)，那么外部模块在被它的传递依赖(transitive dependencies)所require的时候可能并没有执行完成，这种情况下“require“返回的对象必须至少包含此外部模块在调用require函数之前就已经准备完毕的输出。<br>  (4). 如果请求模块不能返回，那么”require“必须抛出一个错误。<br>  (5). require有一个只读的、不可删除的”main“属性。”main“相当于程序根目录的module。如果设置了该属性，则其必须和根目录的module指向相同的对象。<br>  (6). require有个paths属性，该属性是一个具有优先秩序的路径数组，优先级从高到低，路径一直回朔到地根模块目录。<ul><li>(a) paths属性不会存在于沙盒中。</li><li>(b) 在所有模块中paths的attribute均指向相同的值。</li><li>(c) paths是无法被替换的。</li><li>(d) 当paths的attribute存在时，修改paths的内容可能会导致模块无法被正确的搜索到。</li><li>(e) 当paths的attribute存在时，它可能只包含了部分path,当模块加载器在使用这些路径之前或者之后，去检查其它的路径。</li><li>(f) 当paths的attribute存在时,它是模块加载器使paths规范化、标准化的依据。</li></ul></li><li>在一个模块中，存在一个名为”exports“的自由变量，它是一个对象，模块可以在执行的时候把自身API加入到其中。<br>  (1). 模块中必须使用exports对象作为唯一的导出对象。</li><li>在一个模块中，必须存在一个自由变量“module”，并且module是一个对象。<br>  (1). module对象有一个只读的、不可删除的id属性。当执行require(module.id)时，可以通过该id找到对应的module并返回module exports出的对象。<br>  (2). 当创建一个module对象时，该对象可以有一个URI属性。该属性指向对应的模块源文件。该URI不存在于沙盒中。</li></ol><h3 id="模块标识符：-1"><a href="#模块标识符：-1" class="headerlink" title="模块标识符："></a>模块标识符：</h3><p>同CommonJS 1.0中 模块标识符 相关内容。</p><h2 id="三，总结"><a href="#三，总结" class="headerlink" title="三，总结"></a>三，总结</h2><p>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p><h2 id="四，参考资料"><a href="#四，参考资料" class="headerlink" title="四，参考资料"></a>四，参考资料</h2><p>CommonJS &gt; Modules&#x2F;1.0 —- <a href="https://wiki.commonjs.org/wiki/Modules/1.0">Modules&#x2F;1.0 - CommonJS Spec Wiki</a></p><p>CommonJS &gt; Modules&#x2F;1.1 —- <a href="https://wiki.commonjs.org/wiki/Modules/1.1">Modules&#x2F;1.1 - CommonJS Spec Wiki</a></p><h2 id="五，下集预告"><a href="#五，下集预告" class="headerlink" title="五，下集预告"></a>五，下集预告</h2><p>AMD规范</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言规范 </tag>
            
            <tag> Nodejs </tag>
            
            <tag> CommonJS </tag>
            
            <tag> CommonJS规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改sublime3注释的颜色</title>
      <link href="/2019/10/11/xiu-gai-sublime3-zhu-shi-de-yan-se/"/>
      <url>/2019/10/11/xiu-gai-sublime3-zhu-shi-de-yan-se/</url>
      
        <content type="html"><![CDATA[<p>Sublime Text 编辑器的强大之处这里不再赘述。</p><ul><li>说明：本文章基于 Sublime Text 3143 版本。<br>​<br>本文旨在为大家介绍两种修改 Sublime <strong>注释字体颜色</strong>的方式：</li></ul><ol><li><p>Sublime 自带主题注释颜色的修改。</p></li><li><p>通过 Package Control 安装的主题注释颜色的修改。</p></li></ol><h3 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h3><h2 id="一，Sublime-自带主题注释颜色的修改。"><a href="#一，Sublime-自带主题注释颜色的修改。" class="headerlink" title="一，Sublime 自带主题注释颜色的修改。"></a>一，Sublime 自带主题注释颜色的修改。</h2><ul><li>注：这里以使用默认主题 Monokai 为例进行说明。</li></ul><h2 id="另外，这里-图文并茂，你也可以直接看图片显示的步骤。"><a href="#另外，这里-图文并茂，你也可以直接看图片显示的步骤。" class="headerlink" title="另外，这里 图文并茂，你也可以直接看图片显示的步骤。"></a>另外，这里 图文并茂，你也可以直接看图片显示的步骤。</h2><p>1，Preferences -&gt; Package Control -&gt; Install Package</p><p>或者使用快捷键：ctrl + shift + p，调出命令面板，然后手动输入 Package Control: Install Package</p><p>点击运行。<br><img src="/myImg/sublime/comment/comment1.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="加载Install Package"></p><ul><li>注：没有安装 Package Control 的同学自行百度吧！</li></ul><p>2，步骤一执行结束，弹出命令面板之后，搜索 Package Resource Viewer 并安装。<br><img src="/myImg/sublime/comment/comment2.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="安装 package resource viewer"></p><p>3，快捷键 ctrl + shift + p 调出命令面板，搜索 Package Resource Viewer</p><p>然后，选中 Open Resource 项。如下图：</p><p><img src="/myImg/sublime/comment/comment3.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择 open Resource 项"></p><p>4，搜索“Color Scheme -Default”</p><p><img src="/myImg/sublime/comment/comment4.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="搜索 Color Scheme - Default"></p><p>5，搜索”Monokai.tmTheme”,并打开这个XML文件。因为修改的是Monkai的配色方案，所以在Preferences设置的配色方案也要选择这个。否则修改没有效果。<br><img src="/myImg/sublime/comment/comment5.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择 Monokai.tmTheme"></p><p>6，搜索关键字“comment”，找到#75715E,按照自己的喜欢修改颜色，我修改的是绿色，就改为#0AA344。<br><img src="/myImg/sublime/comment/comment6.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="搜索关键字“comment”"></p><p>修改对应字段的颜色值为你想设置的颜色值</p><p>保存后, 显示效果如下：</p><p><img src="/myImg/sublime/comment/comment7.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="最终效果"></p><h2 id="二，通过-Package-Control-安装的主题注释颜色的修改。"><a href="#二，通过-Package-Control-安装的主题注释颜色的修改。" class="headerlink" title="二，通过 Package Control 安装的主题注释颜色的修改。"></a>二，通过 Package Control 安装的主题注释颜色的修改。</h2><ul><li>注：这里以 Boxy 插件的 Boxy Solarized Light 主题为例。</li><li>Boxy 插件的安装，自行百度，这里不再赘述。</li></ul><p>因为，也需要安装 Package Resource Viewer，因此前三步与上述相同，不再赘述。</p><p>1，同上。</p><p>2，同上。</p><p>3，同上。</p><p>4，搜索 “Boxy Theme”（你可以启动读图模式了）。<br><img src="/myImg/sublime/comment/comment8.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="搜索 “Boxy Theme”"></p><p>5，选择 “schemes&#x2F;”。<br><img src="/myImg/sublime/comment/comment9.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择 “schemes/”"></p><p>6，继续寻找 “Boxy Solarized Light.tmTheme”。<br><img src="/myImg/sublime/comment/comment10.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="查找 Boxy Solarized Light.tmThreme"></p><p>7，搜索关键字“comment”，找到#75715E,按照自己的喜欢修改颜色，我修改的是绿色，就改为#0AA344。<br><img src="/myImg/sublime/comment/comment11.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="搜索关键字“comment”"></p><p>修改注释颜色为你想设置的颜色值</p><p>保存后, 显示效果如下：<br><img src="/myImg/sublime/comment/comment12.png" class="lazyload placeholder" data-srcset="/myImg/sublime/comment/comment12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="最终效果"></p><p>本篇终。</p>]]></content>
      
      
      <categories>
          
          <category> Sublime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> 修改注释颜色 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>img和background-image的区别</title>
      <link href="/2019/10/11/img-he-background-image-de-qu-bie/"/>
      <url>/2019/10/11/img-he-background-image-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="一-img-和-background-image-两者本身的意义"><a href="#一-img-和-background-image-两者本身的意义" class="headerlink" title="一, img 和 background-image 两者本身的意义"></a>一, img 和 background-image 两者本身的意义</h2><p>&lt; img &#x2F; &gt;是一个 HTML 元素，它是一个图片，是 HTML 的一个标签</p><p>background-image 是背景图片，是 CSS 的一个样式</p><h2 id="二-标和本"><a href="#二-标和本" class="headerlink" title="二, 标和本"></a>二, 标和本</h2><h3 id="img-是HTML的标签-本"><a href="#img-是HTML的标签-本" class="headerlink" title="img 是HTML的标签(本)"></a>img 是HTML的标签(本)</h3><p>&lt; img &#x2F; &gt;是可以操作的。比如更换img src的路径可以达到更换图片的目的，也可以移动它的位置，从document中移除等等操作</p><p>img 上能写字，能增加其余想增加的元素</p><h3 id="background-image是CSS的样式-标"><a href="#background-image是CSS的样式-标" class="headerlink" title="background-image是CSS的样式(标)"></a>background-image是CSS的样式(标)</h3><p>background-image是只能看的, background-image存在于大的background中，其属性设置多种多样，变换较为丰富</p><p>这是两者的本质区别！</p><h2 id="三-什么时候使用img和background-image"><a href="#三-什么时候使用img和background-image" class="headerlink" title="三, 什么时候使用img和background-image"></a>三, 什么时候使用img和background-image</h2><p>一般来说，如果是装饰性的图片就使用background-img，如果和文体内容很相关就使用 img</p><p>在网页加载的过程中，以CSS背景图存在的图片background-image会等到结构加载完成（网页的内容全部显示以后）才开始加载，而HTML中的标签img是网页结构（内容）的一部分会在加载结构的过程中加载。</p><p>换句话讲，网页会加载标签img的内容，比加载背景图片background-image的时机要早。</p><p>也就意味着, 如果你用引入了一个很大的图片，那么在这个图片下载完成之前，img后的内容都不会显示。而如果用CSS来引入同样的图片，网页结构和内容加载完成之后，才开始加载背景图片，不会影响浏览网页内容。</p><h2 id="四-说重点"><a href="#四-说重点" class="headerlink" title="四, 说重点"></a>四, 说重点</h2><p>简单来说，img 是内容部分的东西，background-image 是修饰性的东西。</p><p>加点文字修饰就是:</p><h3 id="img"><a href="#img" class="headerlink" title="img"></a>img</h3><p>从页面元素来说，如果是页面中的图片是作为内容出现的，比如广告图片，比如产品图片，那么这个必然是用img了，因为这个是页面元素内容。页面元素内容最关键的一点就是，当页面没有样式的时候，还是能一眼看过去就知道什么是什么……</p><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><p>背景图片，修饰性的内容，在页面中可有可无。有，是为了让页面中视觉感受上更美；无，并不影响用户浏览网页获取内容。</p><h2 id="五-只看着一句话就行了！"><a href="#五-只看着一句话就行了！" class="headerlink" title="五, 只看着一句话就行了！"></a>五, 只看着一句话就行了！</h2><p>其实说白了，背景图片就是通过样式加载后，让页面更漂亮而已，内容图片就是为了展示给用户的。假设有一天你的网页没有任何样式的时候，那么这个时候请想想你的网站上哪些图片是给用户看的，这样就足够了。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> img </tag>
            
            <tag> background-image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上传代码到新浪sea</title>
      <link href="/2019/10/11/shang-chuan-dai-ma-dao-xin-lang-sea/"/>
      <url>/2019/10/11/shang-chuan-dai-ma-dao-xin-lang-sea/</url>
      
        <content type="html"><![CDATA[<p>​<br>对于前端开发工程师，在学习阶段，每每GET新技能是不是都想给你的小伙伴展示展示呢？</p><p>然而，由于自己没有服务器，没办法将代码上传，也就限制了你的“展示”。</p><p>这里推荐你一种简洁的方式给大家，可以在一段时间内“免费”展示你的代码，以及获得服务器支持。</p><p>什么呢？新浪云sea，<a href="https://login.sina.com.cn/signup/signin.php?entry=sinacloud&r=https://www.sinacloud.com/ucenter.html">你可以点击这里进行注册！</a></p><p>然后，你就可以把你的代码上传到你的“服务器”，然后就可以开心的把代码分享给你的小伙伴了。</p><p>首先，代码文件和文件夹的名字<strong>不要出现中文！不要出现中文！不要出现中文！</strong></p><p>然后，按照上面 “点击这是进行注册” 的链接，进行注册，然后登陆。</p><p>再然后，按照以下图示操作即可呦！</p><h2 id="一，点击“云应用SAE”"><a href="#一，点击“云应用SAE”" class="headerlink" title="一，点击“云应用SAE”"></a>一，点击“云应用SAE”</h2><p><img src="/myImg/xinlang/pushcode/pushcode1.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="点击云应用SAE"></p><h2 id="二，进入控制台"><a href="#二，进入控制台" class="headerlink" title="二，进入控制台"></a>二，进入控制台</h2><p><img src="/myImg/xinlang/pushcode/pushcode2.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="点击进入控制台"></p><h2 id="三，创建新应用"><a href="#三，创建新应用" class="headerlink" title="三，创建新应用"></a>三，创建新应用</h2><p><img src="/myImg/xinlang/pushcode/pushcode3.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="创建新应用"></p><h2 id="四，应用设置"><a href="#四，应用设置" class="headerlink" title="四，应用设置"></a>四，应用设置</h2><p><img src="/myImg/xinlang/pushcode/pushcode4.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="应用设置"></p><h2 id="五，然后“创建应用”"><a href="#五，然后“创建应用”" class="headerlink" title="五，然后“创建应用”"></a>五，然后“创建应用”</h2><p><img src="/myImg/xinlang/pushcode/pushcode5.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="创建应用"></p><h2 id="六，创建版本"><a href="#六，创建版本" class="headerlink" title="六，创建版本"></a>六，创建版本</h2><p><img src="/myImg/xinlang/pushcode/pushcode6.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="创建版本"></p><h2 id="七，选择版本号"><a href="#七，选择版本号" class="headerlink" title="七，选择版本号"></a>七，选择版本号</h2><p><img src="/myImg/xinlang/pushcode/pushcode7.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择版本号"></p><h2 id="八，上传代码包（代码包中文件和文件夹名字不要出现非英文和空格）"><a href="#八，上传代码包（代码包中文件和文件夹名字不要出现非英文和空格）" class="headerlink" title="八，上传代码包（代码包中文件和文件夹名字不要出现非英文和空格）"></a>八，上传代码包（代码包中文件和文件夹名字不要出现非英文和空格）</h2><p><img src="/myImg/xinlang/pushcode/pushcode8.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="上传代码包"></p><h2 id="九，上传代码压缩包"><a href="#九，上传代码压缩包" class="headerlink" title="九，上传代码压缩包"></a>九，上传代码<strong>压缩包</strong></h2><p><img src="/myImg/xinlang/pushcode/pushcode9.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="上传代码压缩包"></p><h2 id="十，上传结束，点击关闭"><a href="#十，上传结束，点击关闭" class="headerlink" title="十，上传结束，点击关闭"></a>十，上传结束，点击关闭</h2><p><img src="/myImg/xinlang/pushcode/pushcode10.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="上传结束"></p><h2 id="十一，点击“编辑代码”"><a href="#十一，点击“编辑代码”" class="headerlink" title="十一，点击“编辑代码”"></a>十一，点击“编辑代码”</h2><p><img src="/myImg/xinlang/pushcode/pushcode11.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="编辑代码"></p><h2 id="十二，双击刚刚上传的项目"><a href="#十二，双击刚刚上传的项目" class="headerlink" title="十二，双击刚刚上传的项目"></a>十二，双击刚刚上传的项目</h2><p><img src="/myImg/xinlang/pushcode/pushcode12.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="双击项目"></p><h2 id="十三，右键“通过URL访问”"><a href="#十三，右键“通过URL访问”" class="headerlink" title="十三，右键“通过URL访问”"></a>十三，右键“通过URL访问”</h2><p><img src="/myImg/xinlang/pushcode/pushcode13.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="通过URL访问"></p><h2 id="十四，复制链接"><a href="#十四，复制链接" class="headerlink" title="十四，复制链接"></a>十四，复制链接</h2><p><img src="/myImg/xinlang/pushcode/pushcode14.png" class="lazyload placeholder" data-srcset="/myImg/xinlang/pushcode/pushcode14.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="复制链接"></p><h2 id="十五，发送链接给小伙伴。"><a href="#十五，发送链接给小伙伴。" class="headerlink" title="十五，发送链接给小伙伴。"></a>十五，发送链接给小伙伴。</h2><h3 id="Over！"><a href="#Over！" class="headerlink" title="Over！"></a>Over！</h3><p>如有疑问，欢迎留言！</p>]]></content>
      
      
      <categories>
          
          <category> 新浪 SEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新浪 SEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS中文乱码问题的解决方案</title>
      <link href="/2019/10/11/nodejs-zhong-wen-luan-ma-wen-ti-de-jie-jue-fang-an/"/>
      <url>/2019/10/11/nodejs-zhong-wen-luan-ma-wen-ti-de-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<p>​<br>太简单的问题了, 在这里简单记录下。</p><p>NodeJS对中文的支持不是太好，支持 UTF-8，但是不支持BGK。</p><p>这时，需要保证你的 JS 文件是通过 UTF-8 格式保存的，运行之后界面才不会出现乱码。</p><p>解决方法示例，如下图：<br><img src="/myImg/node/lm/lm1.png" class="lazyload placeholder" data-srcset="/myImg/node/lm/lm1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="乱码解决方案"></p><p>页面设置</p><p>之后页面显示就正常了，如下图：<br><img src="/myImg/node/lm/lm2.png" class="lazyload placeholder" data-srcset="/myImg/node/lm/lm2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="运行结果"></p><p>显示效果</p><p>so，easy！</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nodejs </tag>
            
            <tag> 中文乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac版PS-CS6安装补丁</title>
      <link href="/2019/10/11/mac-ban-ps-cs6-an-zhuang-bu-ding/"/>
      <url>/2019/10/11/mac-ban-ps-cs6-an-zhuang-bu-ding/</url>
      
        <content type="html"><![CDATA[<p>​<br><a href="https://pan.baidu.com/share/init?surl=hsn6ubU">可以点击我下载 PS CS6 安装包</a></p><p>密码：yx66</p><p><a href="https://pan.baidu.com/share/init?surl=hsomp7I">然后点击我下载补丁</a></p><p>密码：kc2f</p><h2 id="CS-6-安装"><a href="#CS-6-安装" class="headerlink" title="CS 6 安装"></a>CS 6 安装</h2><h3 id="双击你下载的安装包"><a href="#双击你下载的安装包" class="headerlink" title="双击你下载的安装包"></a>双击你下载的安装包</h3><p><img src="/myImg/ps/az/az1.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="双击安装包"></p><h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p><img src="/myImg/ps/az/az2.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="打开"></p><h3 id="等待安装"><a href="#等待安装" class="headerlink" title="等待安装"></a>等待安装</h3><p><img src="/myImg/ps/az/az3.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="等待安装"></p><h3 id="选择“试用”"><a href="#选择“试用”" class="headerlink" title="选择“试用”"></a>选择“试用”</h3><p><img src="/myImg/ps/az/az4.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="选择“试用”"></p><h3 id="接受协议"><a href="#接受协议" class="headerlink" title="接受协议"></a>接受协议</h3><p><img src="/myImg/ps/az/az5.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="接受协议"></p><h3 id="接下来就是下一步，下一步就行"><a href="#接下来就是下一步，下一步就行" class="headerlink" title="接下来就是下一步，下一步就行"></a>接下来就是下一步，下一步就行</h3><p><img src="/myImg/ps/az/az6.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="接下来就是下一步，下一步就行"></p><h3 id="安装完成，关闭即可"><a href="#安装完成，关闭即可" class="headerlink" title="安装完成，关闭即可"></a>安装完成，关闭即可</h3><p><img src="/myImg/ps/az/az7.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="安装完成，关闭即可"></p><h2 id="接下来可以开启破解流程："><a href="#接下来可以开启破解流程：" class="headerlink" title="接下来可以开启破解流程："></a>接下来可以开启破解流程：</h2><h3 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h3><p><img src="/myImg/ps/az/az8.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="补丁，步骤一"></p><h3 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h3><p><img src="/myImg/ps/az/az9.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="补丁，步骤二"></p><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p><img src="/myImg/ps/az/az10.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="补丁，步骤三"></p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p><img src="/myImg/ps/az/az11.png" class="lazyload placeholder" data-srcset="/myImg/ps/az/az11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="补丁，步骤四"></p><p>接下来就可以你的 PS 之旅了！</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Mac配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac软件安装 </tag>
            
            <tag> PS </tag>
            
            <tag> Photoshop </tag>
            
            <tag> CS6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node更新到最新版</title>
      <link href="/2019/10/11/node-geng-xin-dao-zui-xin-ban/"/>
      <url>/2019/10/11/node-geng-xin-dao-zui-xin-ban/</url>
      
        <content type="html"><![CDATA[<p>​<br>迅速实现 node 版本更新<br>一行终端指令搞定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n stable</span><br></pre></td></tr></table></figure><p>如果终端出现以下信息, 那就重新换一行终端指令.</p><p>信息图片如下:<br><img src="/myImg/node/update/error/error1.png" class="lazyload placeholder" data-srcset="/myImg/node/update/error/error1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="sudo required"></p><p>重新输入的终端指令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure><p>稍等一会儿, 你就可以快乐的输入以下终端指令, 查询你的 node 版本信息了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> node 更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm更新到最新版</title>
      <link href="/2019/10/11/npm-geng-xin-dao-zui-xin-ban/"/>
      <url>/2019/10/11/npm-geng-xin-dao-zui-xin-ban/</url>
      
        <content type="html"><![CDATA[<p>​<br>npm 迅速更新到最新版本<br>终端指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm</span><br></pre></td></tr></table></figure><p>如果终端出现一大堆 npm WARN, 和 npm ERR! 的信息(如下图)</p><p><img src="/myImg/npm/update/error/error1.png" class="lazyload placeholder" data-srcset="/myImg/npm/update/error/error1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="WARN"></p><p>npm WARN</p><p><img src="/myImg/npm/update/error/error2.png" class="lazyload placeholder" data-srcset="/myImg/npm/update/error/error2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ERR"></p><p>npm ERR!</p><p>信息的最后显示如下图的信息:</p><p><img src="/myImg/npm/update/error/error3.png" class="lazyload placeholder" data-srcset="/myImg/npm/update/error/error3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="ERR"></p><p>npm ERR!</p><p>那就是你的权限不够</p><p>输入以下终端指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g npm</span><br></pre></td></tr></table></figure><p>最后, 你就可以输入以下终端指令, 查询你的 npm 版本信息了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> npm 更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emmet插件常用语法汇总</title>
      <link href="/2016/10/11/emmet-cha-jian-chang-yong-yu-fa-hui-zong/"/>
      <url>/2016/10/11/emmet-cha-jian-chang-yong-yu-fa-hui-zong/</url>
      
        <content type="html"><![CDATA[<h2 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法:"></a>emmet语法:</h2><p>1.!+tab:整个html文档</p><p>2.标签名<em>个数:生成对应个数的标签eg:p</em>5</p><p>3.同级是+, 生成同级标签,同时生成一个a和一个img</p><p>4.&gt;:下一级</p><p>5.^:上一级</p><p>6.{}:紧跟标签的后面,表示该标签的内容</p><p>7.#:id (id跟身份证号差不多,在页面中不能出现相同id的标签)</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><p>div.div1 —-&gt; 生成一个class名为div1的div标签</p><p>div#div1 —-&gt; 生成一个id名为div1的div标签</p><p>p*5 —-&gt; 生成5个p标签</p><p>p.*5 —-&gt; 生成5个带有空的class属性的p标签</p><p>p#*5 —-&gt; 生成5个带有空的id属性的p标签</p><p>a+img —-&gt; 生成同级的一个a和一个img</p><p>a.+img. —-&gt; 生成同级的一个a和一个img(此时a和img都有空的class属性)</p><p>a#+img# —-&gt; 生成同级的一个a和一个img(此时a和img都有空的id属性)</p><p>ul&gt;li*5—-&gt; 在ul标签下有5个li标签</p><p>ul&gt;li.*5—-&gt;在ul标签下有5个带有空的class属性值的li标签</p><p>ul&gt;li#*5—-&gt;在ul标签下有5个带有空的id属性值的li标签</p><p>p{我是一个p} —-&gt; 生成一个内容是”我是一个p”的p标签</p><p>(ul&gt;li{1111}*5)<em>3 或者 ul</em>3&gt;li{1111}*5 —-&gt; 生成3个带有5个列表项, 列表项内容为”1111”的无序列表</p><p>……</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果一一列举的话, 还有很多很多, 大致的思路已经提供给大家: 如果想要给标签带 class 就在标签名后面加个点 . ; 如果想要给标签带 id 就在表现后加个 #; 如果给标签设置内容就用大括号 {}; 有层级就用 &gt; 和 ^, 平级就用 +, 个数多就用 *</p><p>简单的这么一个思路, 大家按照这个思路自行扩充即可.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 中的 px，em，rem，百分比</title>
      <link href="/2016/10/11/css-zhong-de-px-em-rem-bai-fen-bi/"/>
      <url>/2016/10/11/css-zhong-de-px-em-rem-bai-fen-bi/</url>
      
        <content type="html"><![CDATA[<h2 id="一，px-—-像素（Pixel）。"><a href="#一，px-—-像素（Pixel）。" class="headerlink" title="一，px —- 像素（Pixel）。"></a>一，px —- 像素（Pixel）。</h2><p>相对长度单位。</p><p>像素px是相对于显示器屏幕分辨率而言的，作为开发人员，我们应该经常与 px 打交道。因此，这里不再赘述，只介绍 px 的特点：</p><ol><li><p>IE无法调整那些使用px作为单位的字体大小；</p></li><li><p>国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位；</p></li><li><p>Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。</p></li></ol><h2 id="二，em-—-emphasize。"><a href="#二，em-—-emphasize。" class="headerlink" title="二，em —- emphasize。"></a>二，em —- emphasize。</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。</p><p>如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p><p>em特点：</p><ol><li><p>em的值并不是固定的；</p></li><li><p>em会继承父级元素的字体大小。</p></li></ol><p>需要注意的是：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em&#x3D;16px。那么12px&#x3D;0.75em,10px&#x3D;0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size&#x3D;62.5%，这就使em值变为 16px*62.5%&#x3D;10px, 这样12px&#x3D;1.2em, 10px&#x3D;1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p><p>所以我们在写CSS的时候，需要注意一下几点：</p><ol><li><p>body选择器中声明Font-size&#x3D;62.5%；</p></li><li><p>将你的原来的px数值除以10，然后换上em作为单位；</p></li><li><p>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。也就是避免1.2 * 1.2&#x3D; 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em&#x3D;12px。</p></li></ol><h2 id="三，rem-—-root-em"><a href="#三，rem-—-root-em" class="headerlink" title="三，rem —- root em"></a>三，rem —- root em</h2><p>rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。代码示例如下：</p><h2 id="四，百分比"><a href="#四，百分比" class="headerlink" title="四，百分比"></a>四，百分比</h2><p>这个名词我就不再解释了，不明白百分比什么意思的请点击这里。</p><p>CSS 中字体单位使用百分比，需要我们手动计算得到字体的百分比。有些麻烦，不常用。</p><h2 id="五，结语"><a href="#五，结语" class="headerlink" title="五，结语"></a>五，结语</h2><p>使用什么样的字体单位，主要由项目来决定。我们可以根据项目的用户群，选择方便的字体单位来使用。比如，我们的用户群都使用的是新版浏览器，那么就可以选择使用 rem；如果考虑到兼容性的问题，我们可以使用 px，或者两者都用。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
            <tag> px </tag>
            
            <tag> em </tag>
            
            <tag> rem </tag>
            
            <tag> 百分比 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods was not able to update the  repo.if it is a unexpected issue and</title>
      <link href="/2016/06/14/cocoapods-was-not-able-to-update-the-repo-if-it-is-a-unexpected-issue-and/"/>
      <url>/2016/06/14/cocoapods-was-not-able-to-update-the-repo-if-it-is-a-unexpected-issue-and/</url>
      
        <content type="html"><![CDATA[<p>​<br>问题：cocoapods was not able to update the ‘master’ repo.if it is a unexpected issue and persists you can inspect it running ‘pod repo update –verbose’</p><p><img src="/myImg/cocoapods/error/error1.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/error/error1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="01"></p><p>尝试解决：</p><p>尝试1、根据提示，跑一下 pod repo update –verbose</p><p>尝试2、如果还是出现原来问题，升级 gem update cocoapods（如果CocoaPods还不是最新版本）</p><p>尝试3、如果升级还是出现原来的问题，那么重装CocoaPods 。</p><p>首先查看本地装了关于cocoapods的哪些东西，在终端输入 gem list –local | grep cocoapods</p><p><img src="/myImg/cocoapods/error/error2.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/error/error2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="02"></p><p>接着全部卸掉上面的，在终端输入gem uninstall cocoapods</p><p>再安装,在终端输入gem install cocoapods</p><p>尝试4、如果问题依旧，那么请清除缓存再pod setup</p><p>清除命令sudo rm -fr ~&#x2F;.cocoapods&#x2F;repos&#x2F;master</p><p>再pod setup</p><p><img src="/myImg/cocoapods/error/error3.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/error/error3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="03"></p><p>如果问题解决了，那么得出的结论是简单来说就是0.32之后的CocoaPods</p><p> repo目录访问现在不需要root权限了，之前版本生成的目录权限在新版本下会有权限问题，所以需要删除重新生成一次。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> CocoaPods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
            <tag> CocoaPods 安装报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSURLSession功能初探（一）</title>
      <link href="/2016/05/29/nsurlsession-gong-neng-chu-tan-yi/"/>
      <url>/2016/05/29/nsurlsession-gong-neng-chu-tan-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、URL-Session的基本概念"><a href="#一、URL-Session的基本概念" class="headerlink" title="一、URL Session的基本概念"></a>一、URL Session的基本概念</h2><p>1.三种工作模式：</p><p>默认会话模式（default）：工作模式类似于原来的NSURLConnection，使用的是基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。</p><p>瞬时会话模式（ephemeral）：该模式不使用磁盘保存任何数据。所有和会话相关的caches，证书，cookies等都被保存在RAM中，因此当程序使会话无效，这些缓存的数据就会被自动清空。</p><p>后台会话模式（background）：该模式在后台完成上传和下载，在创建Configuration对象的时候需要提供一个NSString类型的ID用于标识完成工作的后台会话。</p><p>2.NSURLSession支持的三种任务</p><p>NSURLSession类支持三种类型的任务：加载数据，下载和上传。</p><h2 id="二、相关的类"><a href="#二、相关的类" class="headerlink" title="二、相关的类"></a>二、相关的类</h2><p>NSURLConnection这个名字，实际上指的是一组构成Foundation框架中URL加载系统的相互关联的组件：NSURLRequest，NSURLResponse，NSURLProtocol，NSURLCache，NSHTTPCookieStorage，NSURLCredentialStorage，以及和它同名的NSURLConnection。</p><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。</p><p>NSURLSession也是一组相互依赖的类，它的大部分组件和NSURLConnection中的组件相同如NSURLRequest，NSURLCache等。而NSURLSession的不同之处在于，它将NSURLConnection替换为NSURLSession和NSURLSessionConfiguration，以及3个NSURLSessionTask的子类：NSURLSessionDataTask, NSURLSessionUploadTask, 和NSURLSessionDownloadTask。</p><p>下面来说下NSURLSession新推出的类：</p><p>1.NSURLSessionConfiguration类</p><p>其中NSURLSessionConfiguration用于配置会话的属性，可以通过该类配置会话的工作模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;  </span><br><span class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;  </span><br><span class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfiguration:(NSString *)identifier;  </span><br></pre></td></tr></table></figure><p>在backgroundSessionConfiguration:方法中的identifier参数指定了会话的ID，用于标记后台的session。<br>该类的其中两个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* allow request to route over cellular. */  </span><br><span class="line">@property BOOL allowsCellularAccess;  </span><br><span class="line">  </span><br><span class="line">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */  </span><br><span class="line">@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(NA, 7_0);  </span><br></pre></td></tr></table></figure><p>allowsCellularAccess 属性指定是否允许使用蜂窝连接， discretionary属性为YES时表示当程序在后台运作时由系统自己选择最佳的网络连接配置，该属性可以节省通过蜂窝连接的带宽。在使用后台传输数据的时候，建议使用discretionary属性，而不是allowsCellularAccess属性，因为它会把WiFi和电源可用性考虑在内。补充：这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过Wifi进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在discretionary模式下运行。</p><p>2.NSURLSession类</p><p>获取NSURLSession类对象有几种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * The shared session uses the currently set global NSURLCache, </span><br><span class="line"> * NSHTTPCookieStorage and NSURLCredentialStorage objects. </span><br><span class="line"> */  </span><br><span class="line">+ (NSURLSession *)sharedSession;  </span><br><span class="line">  </span><br><span class="line">/* </span><br><span class="line"> * Customization of NSURLSession occurs during creation of a new session. </span><br><span class="line"> * If you only need to use the convenience routines with custom </span><br><span class="line"> * configuration options it is not necessary to specify a delegate. </span><br><span class="line"> * If you do specify a delegate, the delegate will be retained until after </span><br><span class="line"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message. </span><br><span class="line"> */  </span><br><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;  </span><br><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(NSOperationQueue *)queue;  </span><br></pre></td></tr></table></figure><p>第一种方式是使用静态的sharedSession方法，该类使用共享的会话，该会话使用全局的Cache，Cookie和证书。<br>第二种方式是通过sessionWithConfiguration:方法创建对象，也就是创建对应配置的会话，与NSURLSessionConfiguration合作使用。</p><p>第三种方式是通过sessionWithConfiguration:delegate:delegateQueue方法创建对象，二三两种方式可以创建一个新会话并定制其会话类型。该方式中指定了session的委托和委托所处的队列。当不再需要连接时，可以调用Session的invalidateAndCancel直接关闭，或者调用finishTasksAndInvalidate等待当前Task结束后关闭。这时Delegate会收到URLSession:didBecomeInvalidWithError:这个事件。Delegate收到这个事件之后会被解引用。</p><p>3.NSURLSessionTask类</p><p>NSURLSessionTask是一个抽象子类，它有三个子类：NSURLSessionDataTask，NSURLSessionUploadTask和NSURLSessionDownloadTask。这三个类封装了现代应用程序的三个基本网络任务：获取数据，比如JSON或XML，以及上传和下载文件。</p><p>下面是其继承关系：</p><p><img src="/myImg/iOS/NSURLSession/NSURLSession1.png" class="lazyload placeholder" data-srcset="/myImg/iOS/NSURLSession/NSURLSession1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Leo——NSURLSession继承关系"></p><p>有多种方法创建对应的任务对象：</p><p>（1）NSURLSessionDataTask</p><p>通过request对象或url创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Creates a data task with the given request.  The request may have a body stream. */  </span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;  </span><br><span class="line">  </span><br><span class="line">/* Creates a data task to retrieve the contents of the given URL. */  </span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;  </span><br></pre></td></tr></table></figure><p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * data task convenience methods.  These methods create tasks that </span><br><span class="line"> * bypass the normal delegate calls for response and data delivery, </span><br><span class="line"> * and provide a simple cancelable asynchronous interface to receiving </span><br><span class="line"> * data.  Errors will be returned in the NSURLErrorDomain,  </span><br><span class="line"> * see &lt;Foundation/NSURLError.h&gt;.  The delegate, if any, will still be </span><br><span class="line"> * called for authentication challenges. </span><br><span class="line"> */  </span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </span><br></pre></td></tr></table></figure><p>（2）NSURLSessionUploadTask<br>通过request创建，在上传时指定文件源或数据源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Creates an upload task with the given request.  The body of the request will be created from the file referenced by fileURL */  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </span><br><span class="line">  </span><br><span class="line">/* Creates an upload task with the given request.  The body of the request is provided from the bodyData. */  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </span><br><span class="line">  </span><br><span class="line">/* Creates an upload task with the given request.  The previously set body stream of the request (if any) is ignored and the URLSession:task:needNewBodyStream: delegate will be called when the body payload is required. */  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;  </span><br></pre></td></tr></table></figure><p>在创建upload task对象时，通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * upload convenience method. </span><br><span class="line"> */  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;  </span><br></pre></td></tr></table></figure><p>（3）NSURLSessionDownloadTask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Creates a download task with the given request. */  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;  </span><br><span class="line">  </span><br><span class="line">/* Creates a download task to download the contents of the given URL. */  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;  </span><br><span class="line">  </span><br><span class="line">/* Creates a download task with the resume data.  If the download cannot be successfully resumed, URLSession:task:didCompleteWithError: will be called. */  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;  </span><br></pre></td></tr></table></figure><p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务。<br>同样地可以通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * download task convenience methods.  When a download successfully </span><br><span class="line"> * completes, the NSURL will point to a file that must be read or </span><br><span class="line"> * copied during the invocation of the completion routine.  The file </span><br><span class="line"> * will be removed automatically. </span><br><span class="line"> */  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;  </span><br></pre></td></tr></table></figure><p>4.NSURLSessionDelegate和NSURLSessionTaskDelegate协议</p><p>在协议的方法中可以完成各种各样的回调动作，如身份验证、完成任务后的动作、错误处理和后台任务完成的动作等。委托方法指定在NSURLSession中一定数量的字节传输使用int64_t类型的参数。</p><p>这里只说下后台任务的一个委托方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* If an application has received an </span><br><span class="line"> * -application:handleEventsForBackgroundURLSession:completionHandler: </span><br><span class="line"> * message, the session delegate will receive this message to indicate </span><br><span class="line"> * that all messages previously enqueued for this session have been </span><br><span class="line"> * delivered.  At this time it is safe to invoke the previously stored </span><br><span class="line"> * completion handler, or to begin any internal updates that will </span><br><span class="line"> * result in invoking the completion handler. </span><br><span class="line"> */  </span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session NS_AVAILABLE_IOS(7_0);  </span><br></pre></td></tr></table></figure><p>配合使用ApplicationDelegate的下面这个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Applications using an NSURLSession with a background configuration may be launched or resumed in the background in order to handle the  </span><br><span class="line">// completion of tasks in that session, or to handle authentication. This method will be called with the identifier of the session needing  </span><br><span class="line">// attention. Once a session has been created from a configuration object with that identifier, the session&#x27;s delegate will begin receiving  </span><br><span class="line">// callbacks. If such a session has already been created (if the app is being resumed, for instance), then the delegate will start receiving  </span><br><span class="line">// callbacks without any action by the application. You should call the completionHandler as soon as you&#x27;re finished handling the callbacks.  </span><br><span class="line">- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler NS_AVAILABLE_IOS(7_0);  </span><br></pre></td></tr></table></figure><p>将任务切换到后台之后，Session的Delegate不会再收到和Task相关的消息。当所有Task全都完成后，程序将被唤醒，并调用ApplicationDelegate的application:handleEventsForBackgroundURLSession:completionHandler:回调，在这里要为后台session（由background session的identifier标识）指定对应的回调代码块。<br>随后，对于每一个完成的后台Task调用该Session的Delegate中的URLSession:downloadTask:didFinishDownloadingToURL:（成功的话）和URLSession:task:didCompleteWithError:（成功或者失败都会调用）方法做处理，以上的回调代码块可以在这里调用。</p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NSURLSession </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode安装插件时 Load Bundle 和 Skip Bundle 的差别</title>
      <link href="/2016/05/08/xcode-an-zhuang-cha-jian-shi-load-bundle-he-skip-bundle-de-chai-bie/"/>
      <url>/2016/05/08/xcode-an-zhuang-cha-jian-shi-load-bundle-he-skip-bundle-de-chai-bie/</url>
      
        <content type="html"><![CDATA[<p><strong>很简单：</strong><br>Load Bundle 允许插件在 Xcode 上运行。<br>Skip Bundle 不允许插件在 Xcode 上运行。<br>那不小心点了 Skip Bundle 怎么办？</p><p>步骤如下：<br>查看Xcode的UUID<br>在终端执行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults read `/Applications/Xcode.app/Contents/InfoDVTPlugInCompatibilityUUID`</span><br></pre></td></tr></table></figure><p>复制UUID后面那一串字符串</p><p>然后打开xcode插件所在的目录：<br>~&#x2F;Library&#x2F;Application Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins；<br>选择已经安装的插件例如VVDocumenter-Xcode，右键”显示包内容”；<br>找到info.plist 文件，找到DVTPlugInCompatibilityUUIDs的项目，添加一个Item，Value的值为之前Xcode的UUID，保存。<br>重启 Xcode 之后，重启Xcode时会提示“Load bundle”、 “Skip Bundle”，这里必须选择“Load bundle”，不然插件无法使用。<br>如果手误点击了”Skip Bundle” 肿么办？<br>扇自己两个大嘴巴，再次执行上面的步骤吧！</p>]]></content>
      
      
      <categories>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode </tag>
            
            <tag> Load Bundle </tag>
            
            <tag> Skip Bundle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言中日期的1970</title>
      <link href="/2016/05/06/bian-cheng-yu-yan-zhong-ri-qi-de-1970/"/>
      <url>/2016/05/06/bian-cheng-yu-yan-zhong-ri-qi-de-1970/</url>
      
        <content type="html"><![CDATA[<p>很多编程语言的时间中都要从1970年1月1日0点开始算起，前段时间苹果手机变砖的问题，也是由这个时间点所引起，那1970哪来的这么大魔力？今天我们就来讨论下这个问题。</p><h2 id="一，最懒的一种解释方式是："><a href="#一，最懒的一种解释方式是：" class="headerlink" title="一，最懒的一种解释方式是："></a>一，最懒的一种解释方式是：</h2><p>很多编程语言起源于UNIX系统，而UNIX系统认为1970年1月1日0点是时间纪元，所以我们常说的UNIX时间戳是以1970年1月1日0点为计时起点时间的。</p><p>有个这个懒人的解释，或许也能解决我们对1970的困惑，然而，有些人又会追问，为什么UNIX系统从1970年1月1日开始纪元呢？</p><h2 id="二，我们来深入了解下这其中的缘由："><a href="#二，我们来深入了解下这其中的缘由：" class="headerlink" title="二，我们来深入了解下这其中的缘由："></a>二，我们来深入了解下这其中的缘由：</h2><p>首先我们来来了解下最初的32位系统的计算机：<br>计算机操作系统是32位，而时间也是用32位表示。</p><p>32位能够存储的最大值：2147483647</p><p>另外1年365天的总秒数是 31536000，2147483647&#x2F;31536000 &#x3D; 68.1，也就是说32位能表示的最长时间是68年。68年便是32位操作系统的最长使用年限。</p><p>从1970年开始的话，加上68.1，实际最终到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。</p><p>最早出现的UNIX操作系统考虑到计算机产生的年代（1946年）和应用的时限综合取了1970年1月1日作为UNIX TIME的纪元时间(开始时间)。</p><p>那时间回归现象！！！</p><p>至于时间回归的现象相信随着64为操作系统的产生逐渐得到解决，因为用64位操作系统可以表示到 292,277,026,596年12月4日15时30分08秒，相信我们的N代子孙，哪怕地球毁灭那天都不用愁不够用了，因为这个时间已经是千亿年以后 了。</p><p>至于有些语言中的2001大多是进入新世纪新纪元 !</p>]]></content>
      
      
      <categories>
          
          <category> 计算机中的1970 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机编程语言 </tag>
            
            <tag> 日期中的1970 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS配置文件和程序生命周期</title>
      <link href="/2016/03/26/ios-pei-zhi-wen-jian-he-cheng-xu-sheng-ming-zhou-qi/"/>
      <url>/2016/03/26/ios-pei-zhi-wen-jian-he-cheng-xu-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="Info-plist常见的设置"><a href="#Info-plist常见的设置" class="headerlink" title="Info.plist常见的设置"></a>Info.plist常见的设置</h2><p>建立一个工程后，会在Supporting files文件夹下看到一个“工程名-Info.plist”的文件，该文件对工程做一些运行期的配置，非常重要，不能删除 </p><p>注：在旧版本Xcode创建的工程中，这个配置文件的名字就叫“Info.plist”<br>项目中其他Plist文件不能带有“Info”这个字眼，不然会被错认为是传说中非常重要的“Info.plist”<br>项目中还有一个InfoPlist.strings的文件，跟Info.plist文件的本地化相关 </p><h2 id="Info-plist常见属性"><a href="#Info-plist常见属性" class="headerlink" title="Info.plist常见属性"></a>Info.plist常见属性</h2><p>Localiztion native development region(CFBundleDevelopmentRegion)-本地化相关<br>Bundle display name(CFBundleDisplayName)-程序安装后显示的名称,限制在10－12个字符，如果超出，将被显示缩写名称<br>Icon file(CFBundleIconFile)-app图标名称,一般为Icon.png<br>Bundle version(CFBundleVersion)-应用程序的版本号，每次往App Store上发布一个新版本时，需要增加这个版本号<br>Main storyboard file base name(NSMainStoryboardFile)-主storyboard文件的名称 </p><p>Bundle identifier(CFBundleIdentifier)-项目的唯一标识，部署到真机时用到 </p><p><img src="/myImg/iOS/peizhi/peizhi1.png" class="lazyload placeholder" data-srcset="/myImg/iOS/peizhi/peizhi1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="01"></p><h2 id="pch文件"><a href="#pch文件" class="headerlink" title="pch文件"></a>pch文件</h2><p>项目的Supporting files文件夹下面有个“工程名-Prefix.pch”文件，也是一个头文件 </p><p>pch头文件的内容能被项目中的其他所有源文件共享和访问 </p><p>一般在pch文件中定义一些全局的宏 </p><p>在pch文件中添加下列预处理指令，然后在项目中使用Log(…)来输出日志信息，就可以在发布应用的时候，一次性将NSLog语句移除（在调试模式下，才有定义DEBUG）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef DEBUG </span><br><span class="line">#define Log(...) NSLog(__VA_ARGS__) </span><br><span class="line">#else </span><br><span class="line">#define Log(...) </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h2><p>UIApplication对象是应用程序的象征<br>每一个应用都有自己的UIApplication对象，而且是单例的<br>通过[UIApplication sharedApplication]可以获得这个单例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    UIApplication *appDelgate = [UIApplication sharedApplication];  </span><br><span class="line">    UIApplication *appDelegate1 = [UIApplication sharedApplication];  </span><br><span class="line">//    UIApplication *appDelegate2 = [[UIApplication alloc] init];  //会出错。  </span><br><span class="line">    NSLog(@&quot;%p - %p&quot;, appDelgate, appDelegate1); // 打印显示同一个地址  </span><br></pre></td></tr></table></figure><p>一个iOS程序启动后创建的第一个对象就是UIApplication对象<br>利用UIApplication对象，能进行一些应用级别的操作<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">UIApplication *app = [UIApplication sharedApplication];  </span><br><span class="line"> app.applicationIconBadgeNumber = 998; // 设置应用程序图标上的数字  </span><br><span class="line"> app.networkActivityIndicatorVisible = YES; // 设置状态栏的联网动画  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line"> // 设置状态栏的样式  </span><br><span class="line"> // app.statusBarStyle = UIStatusBarStyleLightContent;  // 与下面方法的区别在于，不可设置动画。  </span><br><span class="line"> [app setStatusBarStyle:UIStatusBarStyleLightContent animated:YES];  </span><br><span class="line">   </span><br><span class="line"> // 设置状态栏是否隐藏  </span><br><span class="line">   app.statusBarHidden = YES;  // 与下面方法的区别在于，不可设置动画。  </span><br><span class="line">  </span><br><span class="line"> [app setStatusBarHidden:YES withAnimation:UIStatusBarAnimationFade];      </span><br><span class="line">  </span><br><span class="line"> NSURL *url = [NSURL URLWithString:@&quot;http://ios.itcast.cn&quot;];  </span><br><span class="line"> [app openURL:url];  </span><br></pre></td></tr></table></figure><p>注：iOS7中 如果想利用UIApplication来管理状态栏，首先得修改Info.plist的设置 </p><p><img src="/myImg/iOS/peizhi/peizhi2.png" class="lazyload placeholder" data-srcset="/myImg/iOS/peizhi/peizhi2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="02"></p><p>在iOS7中，默认情况下，状态栏都是由UIViewController管理的，UIViewController实现下列方法就可以轻松管理状态栏的可见性和样式<br>状态栏的样式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (UIStatusBarStyle)preferredStatusBarStyle;   </span><br></pre></td></tr></table></figure><p>状态栏的可见性 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)prefersStatusBarHidden;  </span><br></pre></td></tr></table></figure><h2 id="openURL"><a href="#openURL" class="headerlink" title="openURL"></a>openURL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)openURL:(NSURL*)url;  </span><br></pre></td></tr></table></figure><p>openURL:方法的部分功能有<br>打电话 ，发短信，发邮件，打开一个网页资源 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 打电话   </span><br><span class="line">UIApplication *app = [UIApplication sharedApplication];   </span><br><span class="line">[app openURL:[NSURL URLWithString:@&quot;tel://10086&quot;]];  </span><br><span class="line">// 发短信   </span><br><span class="line">[app openURL:[NSURL URLWithString:@&quot;sms://10086&quot;]];   </span><br><span class="line">// 发邮件   </span><br><span class="line">[app openURL:[NSURL URLWithString:@&quot;mailto://12345@qq.com&quot;]];  </span><br><span class="line">// 打开一个网页资源   </span><br><span class="line">[app openURL:[NSURL URLWithString:@&quot;http://ios.itcast.cn&quot;]];  </span><br></pre></td></tr></table></figure><h2 id="iOS程序的启动过程"><a href="#iOS程序的启动过程" class="headerlink" title="iOS程序的启动过程"></a>iOS程序的启动过程</h2><p><img src="/myImg/iOS/peizhi/peizhi3.png" class="lazyload placeholder" data-srcset="/myImg/iOS/peizhi/peizhi3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="03"></p><p>UIApplication和delegate<br>delegate可处理的事件包括：<br>应用程序的生命周期事件(如程序启动和关闭)<br>系统事件(如来电)<br>内存警告 </p><p>main函数中执行了一个UIApplicationMain这个函数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName);</span><br></pre></td></tr></table></figure><p>argc 传入了几个参数<br>argv 传入参数的值<br>principalClassName：指定应用程序类名（app的象征），该类必须是UIApplication(或子类)。如果为nil,则用UIApplication类作为默认值<br>delegateClassName：指定应用程序的代理类，该类必须遵守UIApplicationDelegate协议</p><h2 id="AppDelegate-方法解释"><a href="#AppDelegate-方法解释" class="headerlink" title="AppDelegate 方法解释"></a>AppDelegate 方法解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 当应用程序启动完毕的时候就会调用(系统自动调用)  </span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  </span><br><span class="line">&#123;  </span><br><span class="line">    return YES;  </span><br><span class="line">&#125;  </span><br><span class="line">// 即将失去活动状态的时候调用(失去焦点, 不可交互)  </span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 重新获取焦点(能够和用户交互)  </span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 应用程序进入后台的时候调用  </span><br><span class="line">// 一般在该方法中保存应用程序的数据, 以及状态  </span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 应用程序即将进入前台的时候调用  </span><br><span class="line">// 一般在该方法中恢复应用程序的数据,以及状态  </span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 应用程序即将被销毁的时候会调用该方法  </span><br><span class="line">// 注意:如果应用程序处于挂起状态的时候无法调用该方法  </span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 应用程序接收到内存警告的时候就会调用  </span><br><span class="line">// 一般在该方法中释放掉不需要的内存  </span><br><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h2><p>UIWindow是一种特殊的UIView，通常在一个app中只会有一个UIWindow<br>iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了</p><p>一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow<br>也就说，没有UIWindow，就看不见任何UI界面 </p><p>创建UIWindow对象和设置window根视图控制器的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 程序启动完毕之后就会调用一次，（AppDelegate中的方法）  </span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions  </span><br><span class="line">&#123;  </span><br><span class="line">       //创建window</span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    //创建视图控制器</span><br><span class="line">    RootViewController *rootVC = [[RootViewController alloc] init];</span><br><span class="line">    //指定window的根视图控制器</span><br><span class="line">    self.window.rootViewController = rootVC;</span><br><span class="line">    //让window成为主窗口并且可视</span><br><span class="line">    [self.window makeKeyAndVisible]; </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="UIWindow的获得"><a href="#UIWindow的获得" class="headerlink" title="UIWindow的获得"></a>UIWindow的获得</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取应用程序的主窗口  </span><br><span class="line">    NSLog(@&quot;%@&quot;, [UIApplication sharedApplication].keyWindow);  </span><br><span class="line">  </span><br><span class="line">// 获得某个UIView所在的UIWindow   </span><br><span class="line">view.window  </span><br></pre></td></tr></table></figure><p>注：用来接收键盘以及非触摸类的消息事件的UIWindow，而且程序中每个时刻只能有一个UIWindow是keyWindow。如果某个UIWindow内部的文本框不能输入文字，可能是因为这个UIWindow不是keyWindow（特别是IOS7之前）</p><p>四大对象关系图</p><p><img src="/myImg/iOS/peizhi/peizhi4.png" class="lazyload placeholder" data-srcset="/myImg/iOS/peizhi/peizhi4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="04"></p><p>生命周期方法<br><img src="/myImg/iOS/peizhi/peizhi5.png" class="lazyload placeholder" data-srcset="/myImg/iOS/peizhi/peizhi5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="05"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Info.plist </tag>
            
            <tag> pch文件 </tag>
            
            <tag> UIApplication </tag>
            
            <tag> iOS程序的启动过程 </tag>
            
            <tag> AppDelegate 方法解释 </tag>
            
            <tag> UIWindow </tag>
            
            <tag> iOS程序生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS伪拷贝, 浅拷贝, 深拷贝</title>
      <link href="/2016/03/20/ios-wei-kao-bei-qian-kao-bei-shen-kao-bei/"/>
      <url>/2016/03/20/ios-wei-kao-bei-qian-kao-bei-shen-kao-bei/</url>
      
        <content type="html"><![CDATA[<p>先来说说<strong>伪拷贝</strong>。<br>伪拷贝就是生成了一个指针变量，指向了某一个对象。<br>接下来我们来探讨下<strong>浅拷贝</strong>和<strong>深拷贝</strong>。<br>首先，从 copy 开始说，简而言之，copy 的目的就是生成一个新的实例，然后把其成员都按原实例赋值。对于非指针型的成员，比如 BOOL, int, float，这样的赋值可以直接进行。但是对于指针型的数据，比如 Objc 中用到的对象，就有 Deep Copy 和 Shallow Copy 的区别——这个和在 C++ 中的基本上是一样的：是生成新的成员对象，或是指向同一成员对象。 </p><p>了解了这点以后，再看看 Copy 在 Objetive-C 中的实现方式。如果要调用一个对象的 copy 方法，这个对象必须遵循 NSCopying 的协议。这个协议中规定了一个方法：- (id)copyWithZone: ( NSZone  * )zone; 我们就是通过实现这个方法给对象提供拷贝的功能。对于很多现有类，如 NSString，NSDictionary，。。。这个方法已经实现。假设我们现在自定义了一个类，需要为这个类提供拷贝的功能，就需要自己来动手写 CopyWithZone 的方法：示例如下：</p><p>这个是自定义的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Product : NSObject &lt;NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">NSString *productName;</span><br><span class="line">float price;</span><br><span class="line">id delegate;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后我们需要在 Product 类中实现 NSCopying 中的 copyWithZone 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">Product *copy = [[[self class] allocWithZone: zone]</span><br><span class="line">initWithProductName:[self productName]</span><br><span class="line">price:[self price]]; //注意这里，我们使用了 class 的 allocWithZone 的方法创建了一个拷贝，这里假定 Product 类中有一个 initWithProductName: price: 的初始化方法。那么这样调用后就得到了一个 Product 的副本，而且 name 和 price 都已经设置好了</span><br><span class="line"></span><br><span class="line">[copy setDelegate:[self delegate]]; //这里再设置delegate</span><br><span class="line"></span><br><span class="line">return copy; //返回副本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这样，如果我们有一个 product 的实例, 假设为product1，然后调用 Product *product2 &#x3D; [product1 copy];<br>就会使用我们上面写的 copyWithZone 的方法创建一个 product1 的副本，然后赋值给 product2。</p><p>这里再以上面方法中的成员delegate为例，解释一下<strong>deep copy</strong>和<strong>shallow copy</strong>：</p><p>在 copyWithZone 方法中，我们得到了一个新的 product 实例，但是 delegate 是个对象，所以在副本中，我们可以选择创建一个新的 delegate 对象（deep copy），或是指向同一个 delegate（shallow copy）。这个就取决于 Product 类中的 setDelegate: 方法了。你可以选择在 setDelegate 的时候，copy，也可以让它们都指向同一个对象（但是需要 retain，原因可以自己思考一下），当然，简单 assign 在某种情况下也是可以的。</p><p>假设在Product类中有setDelegate:方法，或是有delegate的property：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate: (id)aDelegate</span><br><span class="line">&#123;</span><br><span class="line">[delegate release];</span><br><span class="line">delegate = [delegate copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就是一个<strong>深拷贝</strong>了，因为使用了 delegate 的 copy 方法得到了一个 delegate 的副本。至于如何得到 delegate 的副本，就要看 delegate 的 copyWithZone 方法的实现了，不在这个层面的考虑中。也就是说，copy 总是一中“递归”的形式，从上到下，我们可以一层一层的考虑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate: (id)aDelegate</span><br><span class="line">&#123;</span><br><span class="line">[delegate release];</span><br><span class="line">delegate = [aDelegate retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作后，delegate 和 aDelegate 为同一对象，但是为了内存管理方面的要求，我们调用了 retain 来将 reference count 加了一。当然，如果不需要了，还可以直接赋值（assign）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate: (id)aDelegate &#123;</span><br><span class="line">delegate = aDelegate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以把这个例子自己实现一下，然后用log打一打内存，这个结构就很明了了。</p><p>然后再说一下可变副本（mutable copy）和不可变副本(immutable copy)：</p><p>一般来说，如果我们的某个类需要区别对待这两个功能——同时提供创建可变副本和不可变副本的话，一般在 NSCopying 协议规定的方法 copyWithZone 中返回不可变副本；而在 NSMutableCopying 的 mutableCopyWithZone 方法中返回可变副本。然后调用对象的 copy 和 mutableCopy 方法来得到副本。</p><p>举个例子：</p><p>NSDictionary类已经遵循了NSCopying和NSMutableCopy的协议，也就是说我们可以调用它的copy和mutableCopy来得到不可变和可变的副本，程序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *testDict = [[NSDictionary alloc]initWithObjectsAndKeys:@”hello”, @”test”,nil];</span><br><span class="line">NSDictionary *destDict = [testDict copy];</span><br><span class="line">NSLog(@”test Dict:%p,retain Count: %dndest Dict:%p, retain Count: %d”,testDict,[testDict retainCount],destDict,[destDict retainCount]);</span><br></pre></td></tr></table></figure><p>这个在我机器上的运行结果为：</p><p>test Dict:0x11f220, retain Count: 2</p><p>dest Dict:0x11f220,retain Count: 2</p><p>看起来，两个dict指向了同一片内存区域，但是retainCount加了1。这点需要理解一下，因为我们使用NSCopying方法要返回一个不可变对象。而且原来的testDict也是不可变的，那么这里的“副本”也就没多大意义了（这就如同使用字符串常量时，系统会为我们优化，声明了多个字符串，但是都是常量，且内容相等，那么系统就只为我们申请一块空间，这个道理是一样的）。既然都不可变，那么指向同一个空间就可以了。这里的 copy 和 retain 没什么区别。</p><p>我们使用copyWithZone的方法返回immutable的对象，而不管原来的是可变的或是不可变的。我们再看一下如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *testDict = [[NSMutableDictionary alloc]initWithObjectsAndKeys:@”hello”, @”test”,nil];</span><br><span class="line">NSMutableDictionary *destDict = [testDict copy];</span><br><span class="line">NSLog(@”test Dict:%p,retain count:%dndest Dict:%p,retain count:%d”,testDict,[testDict retainCount],destDict,[destDict retainCount]);</span><br><span class="line">[destDict setObject:@&quot;what&quot; forKey:@&quot;test2&quot;];</span><br></pre></td></tr></table></figure><p>NSMutableDictionary是可变的，该代码在我机器上运行的结果为：</p><p>test Dict:0x20dcc0,retain count:1</p><p>dest Dict:0×209120,retain count:1</p><p>*** -[NSCFDictionary setObject:forKey:]: mutating method sent to immutable object</p><p>可以看到因为我们调用了可变对象的copy方法，这个不像之前的例子中一样，只是retain了一下。这里的 test dict 和 dest Dict 已经是两个对象了，但是，copyWithZone 的方法返回的是不可变的对象，因此之后的setObject: forKey:方法会出现错误。</p><p>下面这样改一下就 OK 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *testDict = [[NSMutableDictionary alloc]initWithObjectsAndKeys:@”hello”, @”test”,nil];</span><br><span class="line">NSMutableDictionary *destDict = [testDict mutableCopy];</span><br><span class="line">NSLog(@”test Dict:%p,retain count:%dndest Dict:%p,retain count:%d”,testDict,[testDict retainCount],destDict,[destDict retainCount]);</span><br><span class="line">[destDict setObject:@&quot;what&quot; forKey:@&quot;test2&quot;];</span><br><span class="line">NSLog(@”destDict:%@”,destDict);</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p>test Dict:0×123550,retain count:1</p><p>dest Dict:0x10a460,retain count:1</p><p>因为我们使用了mutableCopy来得到了一个可变副本。</p><p>Note：对于系统提供的所有既支持NSCopying，又支持NSMutableCopying的类。</p><p>copy方法，得到的是不可变对象，不管以前的是可变还是不可变。</p><p>mutableCopy方法，得到的是可变对象，不管以前的是可变还是不可变。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结: "></a>总结: </h2><p><strong>伪拷贝</strong>是指针变量直接指向对象空间；<br><strong>浅拷贝</strong>是指针变量指向了对象所处的空间，同时引起引用计数的变化（增加）；<br><strong>深拷贝</strong>是指针变量指向了一块复制出来的与原对象中内容一模一样的新的空间。</p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS伪拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS中CocoaPods的安装和使用详解</title>
      <link href="/2016/03/15/ios-zhong-cocoapods-de-an-zhuang-he-shi-yong-xiang-jie/"/>
      <url>/2016/03/15/ios-zhong-cocoapods-de-an-zhuang-he-shi-yong-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="首先-CocoaPods是什么"><a href="#首先-CocoaPods是什么" class="headerlink" title="首先, CocoaPods是什么 ?"></a>首先, CocoaPods是什么 ?</h2><p>当你开发iOS应用时，会经常使用到很多第三方开源类库，比如JSONKit，AFNetWorking等等。可能某个类库又用到其他类库，所以要使用它，必须得另外下载其他类库，而其他类库又用到其他类库，“子子孙孙无穷尽也”，这也许是比较特殊的情况。总之小编的意思就是，手动一个个去下载所需类库十分麻烦。另外一种常见情况是，你项目中用到的类库有更新，你必须得重新下载新版本，重新加入到项目中，十分麻烦。如果能有什么工具能解决这些恼人的问题，那将“善莫大焉”。所以，你需要 CocoaPods。<br>CocoaPods应该是iOS最常用最有名的类库管理工具了，上述两个烦人的问题，通过cocoaPods，只需要一行命令就可以完全解决，当然前提是你必须正确设置它。重要的是，绝大部分有名的开源类库，都支持CocoaPods。所以，作为iOS程序员的我们，掌握CocoaPods的使用是必不可少的基本技能了。</p><h2 id="一-CocoaPods的安装"><a href="#一-CocoaPods的安装" class="headerlink" title="一, CocoaPods的安装"></a>一, CocoaPods的安装</h2><p>iOS 最新版 CocoaPods 的安装流程步骤如下:</p><p>1.移除现有Ruby默认源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gem</span> sources --remove https://rubygems.org/</span><br></pre></td></tr></table></figure><p>2.使用新的源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gem</span> sources -a https://ruby.taobao.org/</span><br></pre></td></tr></table></figure><p>3.验证新源是否替换成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gem</span> sources -l</span><br></pre></td></tr></table></figure><p>4.安装CocoaPods, 使用以下两个指令:</p><ul><li>(1):  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> gem install cocoapods </span><br></pre></td></tr></table></figure>备注：苹果系统升级 OS X EL Capitan 后改为  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> gem install -n /usr/local/bin cocoapods</span><br></pre></td></tr></table></figure>(2):  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$pod</span> setup</span><br></pre></td></tr></table></figure></li><li></li></ul><p>然后就是等待安装完成.</p><h2 id="二-CocoaPods的使用"><a href="#二-CocoaPods的使用" class="headerlink" title="二, CocoaPods的使用"></a>二, CocoaPods的使用</h2><p>安装完cocoaPods之后, cocoaPods的使用: </p><p><img src="/myImg/cocoapods/anzhuang/cocoapods1.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="01"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods2.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="02"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods3.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="03"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods4.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="04"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods5.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="05"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods6.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="06"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods7.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="07"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods8.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="08"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods9.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="09"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods10.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="10"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods11.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="11"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods12.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods12.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="12"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods13.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="13"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods14.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods14.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="14"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods15.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="15"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods16.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods16.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="16"></p><p><img src="/myImg/cocoapods/anzhuang/cocoapods17.png" class="lazyload placeholder" data-srcset="/myImg/cocoapods/anzhuang/cocoapods17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="17"></p>]]></content>
      
      
      <categories>
          
          <category> CocoaPods </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS抓取APP中的素材</title>
      <link href="/2016/02/02/ios-zhua-qu-app-zhong-de-su-cai/"/>
      <url>/2016/02/02/ios-zhua-qu-app-zhong-de-su-cai/</url>
      
        <content type="html"><![CDATA[<p>​<br>有时候，我们看到别人的APP做得挺漂亮的，那么我们想查看该APP的图片素材，要怎么弄呢？</p><h2 id="一、下载一个iTools，安装，与手机链接。点击应用，选择我们要查看的APP，选择备份，保存到桌面。"><a href="#一、下载一个iTools，安装，与手机链接。点击应用，选择我们要查看的APP，选择备份，保存到桌面。" class="headerlink" title="一、下载一个iTools，安装，与手机链接。点击应用，选择我们要查看的APP，选择备份，保存到桌面。"></a>一、下载一个iTools，安装，与手机链接。点击应用，选择我们要查看的APP，选择备份，保存到桌面。</h2><p><img src="/myImg/iOS/zhuabao/zhuabao1.png" class="lazyload placeholder" data-srcset="/myImg/iOS/zhuabao/zhuabao1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></p><h2 id="二、回到桌面，解压该-ipa文件"><a href="#二、回到桌面，解压该-ipa文件" class="headerlink" title="二、回到桌面，解压该.ipa文件"></a>二、回到桌面，解压该.ipa文件</h2><p><img src="/myImg/iOS/zhuabao/zhuabao2.png" class="lazyload placeholder" data-srcset="/myImg/iOS/zhuabao/zhuabao2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></p><h2 id="三、解压后，我们选择Payload–》News–-显示包内容"><a href="#三、解压后，我们选择Payload–》News–-显示包内容" class="headerlink" title="三、解压后，我们选择Payload–》News–&gt;显示包内容"></a>三、解压后，我们选择Payload–》News–&gt;显示包内容</h2><p><img src="/myImg/iOS/zhuabao/zhuabao3.png" class="lazyload placeholder" data-srcset="/myImg/iOS/zhuabao/zhuabao3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></p><h2 id="四、这样我们就可以拿到我们想要的APP图片素材了。"><a href="#四、这样我们就可以拿到我们想要的APP图片素材了。" class="headerlink" title="四、这样我们就可以拿到我们想要的APP图片素材了。"></a>四、这样我们就可以拿到我们想要的APP图片素材了。</h2><p><img src="/myImg/iOS/zhuabao/zhuabao4.png" class="lazyload placeholder" data-srcset="/myImg/iOS/zhuabao/zhuabao4.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> iOS素材抓取 </tag>
            
            <tag> 抓取素材 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谓词</title>
      <link href="/2016/01/07/wei-ci/"/>
      <url>/2016/01/07/wei-ci/</url>
      
        <content type="html"><![CDATA[<p>​今天我们在来看一下OC中给我们提供的一个技术：谓词(NSPredicate)</p><p>OC中的谓词操作是针对于数组类型的，他就好比数据库中的查询操作，数据源就是数组，这样的好处是我们不需要编写很多代码就可以去操作数组，同时也起到过滤的作用，我们可以编写简单的谓词语句，就可以从数组中过滤出我们想要的数据。非常方便。在Java中是没有这种技术的，但是有开源的框架已经实现了此功能。</p><p>下面来看一下具体的例子吧：</p><p>Person.h</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  </span><br><span class="line">//  Person.h  </span><br><span class="line">//  46_NSPredicate  </span><br><span class="line">//  </span><br><span class="line">//  Created by jiangwei on 14-10-18.  </span><br><span class="line">//  Copyright (c) 2014年 jiangwei. All rights reserved.  </span><br><span class="line">//  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#import &lt;Foundation/Foundation.h&gt;  </span></span><br><span class="line">  </span><br><span class="line">@interface Person : NSObject  </span><br><span class="line">  </span><br><span class="line">@property NSString *name;  </span><br><span class="line">@property NSInteger age;  </span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">id</span>)personWithName:(NSString *)name andAge:(NSInteger)age;  </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Person.m</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//  </span><br><span class="line">//  Person.m  </span><br><span class="line">//  46_NSPredicate  </span><br><span class="line">//  </span><br><span class="line">//  Created by jiangwei on 14-10-18.  </span><br><span class="line">//  Copyright (c) 2014年 jiangwei. All rights reserved.  </span><br><span class="line">//  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#import &quot;Person.h&quot;  </span></span><br><span class="line">  </span><br><span class="line">@implementation Person  </span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">id</span>)personWithName:(NSString *)name andAge:(NSInteger)age&#123;  </span><br><span class="line">    Person *person = [[Person alloc] init];  </span><br><span class="line">    person.name = name;  </span><br><span class="line">    person.age = age;  </span><br><span class="line">    <span class="built_in">return</span> person;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (NSString *)description&#123;  </span><br><span class="line">    NSString *s =[NSString stringWithFormat:@<span class="string">&quot;name=%@,age=%ld&quot;</span>,_name,_age];  </span><br><span class="line">    <span class="built_in">return</span> s;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>我们在Person类中定义属性，还有一个产生对象的类方法，同时重写了description方法，用于打印结果</p><p>测试方法</p><p>main.m</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//  </span><br><span class="line">//  main.m  </span><br><span class="line">//  46_NSPredicate  </span><br><span class="line">//  </span><br><span class="line">//  Created by jiangwei on 14-10-18.  </span><br><span class="line">//  Copyright (c) 2014年 jiangwei. All rights reserved.  </span><br><span class="line">//  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#import &lt;Foundation/Foundation.h&gt;  </span></span><br><span class="line"><span class="comment">#import &quot;Person.h&quot;  </span></span><br><span class="line">  </span><br><span class="line">//谓词，指定过滤器的条件，将符合条件的对象保留下来  </span><br><span class="line">//一般用谓词过滤数组中指定的元素  </span><br><span class="line">int main(int argc, const charchar * argv[]) &#123;  </span><br><span class="line">    @autoreleasepool &#123;  </span><br><span class="line">         </span><br><span class="line">        NSArray *persons = [NSArray arrayWithObjects:  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;mac&quot;</span> andAge:20],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;1&quot;</span> andAge:30],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;2&quot;</span> andAge:40],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;3&quot;</span> andAge:50],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;4&quot;</span> andAge:60],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;5&quot;</span> andAge:70],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;6&quot;</span> andAge:20],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;7&quot;</span> andAge:40],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;8&quot;</span> andAge:60],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;9&quot;</span> andAge:40],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;0&quot;</span> andAge:80],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;10&quot;</span> andAge:90],  </span><br><span class="line">                            [Person personWithName:@<span class="string">&quot;1&quot;</span> andAge:20]];  </span><br><span class="line">          </span><br><span class="line">        //年龄小于30  </span><br><span class="line">        //定义谓词对象，谓词对象中包含了过滤条件  </span><br><span class="line">        NSPredicate *predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;age&lt;%d&quot;</span>,30];  </span><br><span class="line">        //使用谓词条件过滤数组中的元素，过滤之后返回查询的结果  </span><br><span class="line">        NSArray *array = [persons filteredArrayUsingPredicate:predicate];  </span><br><span class="line">        NSLog(@<span class="string">&quot;filterArray=%@&quot;</span>,array);  </span><br><span class="line">          </span><br><span class="line">        //查询name=1的并且age大于40  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name=&#x27;1&#x27; &amp;&amp; age&gt;40&quot;</span>];  </span><br><span class="line">        array = [persons filteredArrayUsingPredicate:predicate];  </span><br><span class="line">        NSLog(@<span class="string">&quot;filterArray=%@&quot;</span>,array);  </span><br><span class="line">          </span><br><span class="line">        //in(包含)  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;self.name IN &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;&#125; || self.age IN&#123;30,40&#125;&quot;</span>];  </span><br><span class="line">          </span><br><span class="line">        //name以a开头的  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name BEGINSWITH &#x27;a&#x27;&quot;</span>];  </span><br><span class="line">        //name以ba结尾的  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name ENDSWITH &#x27;ba&#x27;&quot;</span>];  </span><br><span class="line">          </span><br><span class="line">        //name中包含字符a的  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name CONTAINS &#x27;a&#x27;&quot;</span>];  </span><br><span class="line">          </span><br><span class="line">        //like 匹配任意多个字符  </span><br><span class="line">        //name中只要有s字符就满足条件  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name like &#x27;*s*&#x27;&quot;</span>];  </span><br><span class="line">        //?代表一个字符，下面的查询条件是：name中第二个字符是s的  </span><br><span class="line">        predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name like &#x27;?s&#x27;&quot;</span>];  </span><br><span class="line">        </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">return</span> 0;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先我们看到，我们初始化了一定大小的数组。</p><p>然后我们就可以使用NSPredicate类进行过滤操作了</p><p>1, 查询数组中年龄小于30的对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//年龄小于30  </span><br><span class="line">//定义谓词对象，谓词对象中包含了过滤条件  </span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;age&lt;%d&quot;</span>,30];  </span><br><span class="line">//使用谓词条件过滤数组中的元素，过滤之后返回查询的结果  </span><br><span class="line">NSArray *array = [persons filteredArrayUsingPredicate:predicate];  </span><br><span class="line">NSLog(@<span class="string">&quot;filterArray=%@&quot;</span>,array);  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先创立一个过滤条件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义谓词对象，谓词对象中包含了过滤条件  </span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;age&lt;%d&quot;</span>,30];  </span><br></pre></td></tr></table></figure><p>这里面操作很简单的：@”age&lt;%d”,这个age是Person的属性名，%d相当于占位符，然后后面用参数替换即可.<br>然后进行过滤操作，返回一个过滤之后的数组对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用谓词条件过滤数组中的元素，过滤之后返回查询的结果  </span><br><span class="line">NSArray *array = [persons filteredArrayUsingPredicate:predicate];  </span><br></pre></td></tr></table></figure><p>2, 查询name&#x3D;1并且age大于40的集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//查询name=1的并且age大于40  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name=&#x27;1&#x27; &amp;&amp; age&gt;40&quot;</span>];  </span><br><span class="line">array = [persons filteredArrayUsingPredicate:predicate];  </span><br><span class="line">NSLog(@<span class="string">&quot;filterArray=%@&quot;</span>,array); </span><br></pre></td></tr></table></figure><p>当然我们也可以使用&amp;&amp;进行多条件过滤</p><p>3, 包含语句的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//in(包含)  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;self.name IN &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;4&#x27;&#125; || self.age IN&#123;30,40&#125;&quot;</span>];</span><br></pre></td></tr></table></figure><p>4, 指定字符开头和指定字符结尾，是否包含指定字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//name以a开头的  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name BEGINSWITH &#x27;a&#x27;&quot;</span>];  </span><br><span class="line">//name以ba结尾的  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name ENDSWITH &#x27;ba&#x27;&quot;</span>];  </span><br><span class="line">  </span><br><span class="line">//name中包含字符a的  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name CONTAINS &#x27;a&#x27;&quot;</span>];</span><br></pre></td></tr></table></figure><p>5, like进行匹配多个字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//like 匹配任意多个字符  </span><br><span class="line">//name中只要有s字符就满足条件  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name like &#x27;*s*&#x27;&quot;</span>];  </span><br><span class="line">//?代表一个字符，下面的查询条件是：name中第二个字符是s的  </span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;name like &#x27;?s&#x27;&quot;</span>];</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>这一篇就介绍了OC中常用的技术：谓词的使用，他用起来很方便的，而且也没什么难度，和我们当初在操作数据库的时候很想，但是他对我们进行过滤操作提供了很大的便捷。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> OC谓词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 中的观察者模式, KVO, 通知</title>
      <link href="/2015/12/20/ios-zhong-de-guan-cha-zhe-mo-shi-kvo-tong-zhi/"/>
      <url>/2015/12/20/ios-zhong-de-guan-cha-zhe-mo-shi-kvo-tong-zhi/</url>
      
        <content type="html"><![CDATA[<p>​</p><h2 id="一-KVO"><a href="#一-KVO" class="headerlink" title="一, KVO"></a>一, KVO</h2><p>Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。每次指定的被观察的对象的属性被修改后，KVO自动通知相应的观察者。</p><p>KVO提供了一种key-value-observing的机制，也就是说可以通过监听key，来获得value的变化。用来在对象之间监听状态变化。使用KVO的类要遵循 协议，事实上，任何继承自NSObject的类，都遵循了这个协议。而Object C中，几乎所有的类都源自NSObject</p><p>什么情况下用KVO ?</p><ol><li>通常适用于根据A类(数据类)的某个属性值变化，B(view类)中的某个属性（控件状态）做出相应变化。体现了MVC的思想</li><li>比如用于用户界面交互，当多个View共同使用了同一个实体（数据类），当这个实体中的某个属性改变时，如果需要更新多个界面，KVO就能发挥作用了</li><li>拷贝大文件的时候监听已拷贝的文件大小，该功能适合用于loading的时候用</li></ol><p>model中的定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface StockData : NSObject &#123;</span><br><span class="line">    NSString * stockName;</span><br><span class="line">    <span class="built_in">float</span> price;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation StockData</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>controller中使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    stockForKVO = [[StockData alloc] init];</span><br><span class="line">    //使用KVC进行赋值</span><br><span class="line">    //注意: 想要使用KVO得到新的变化后的数据, Model的属性必须要求使用KVC进行赋值才行.</span><br><span class="line">    [stockForKVO setValue:@<span class="string">&quot;searph&quot;</span> forKey:@<span class="string">&quot;stockName&quot;</span>];</span><br><span class="line">    [stockForKVO setValue:@<span class="string">&quot;10.0&quot;</span> forKey:@<span class="string">&quot;price&quot;</span>];</span><br><span class="line">    //使用KVO, 注册观察者    </span><br><span class="line">    [stockForKVO addObserver:self forKeyPath:@<span class="string">&quot;price&quot;</span> options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL];</span><br><span class="line">    /*</span><br><span class="line">    注册通知</span><br><span class="line"></span><br><span class="line">    observer:观察者，也就是KVO通知的订阅者。订阅着必须实现 observeValueForKeyPath:ofObject:change:context:方法 keyPath：描述将要观察的属性，相对于被观察者。 options：KVO的一些属性配置；有四个选项。 context: 上下文，这个会传递到订阅着的函数中，用来区分消息，所以应当是不同的。</span><br><span class="line">    options所包括的内容</span><br><span class="line"></span><br><span class="line">    NSKeyValueObservingOptionNew：change字典包括改变后的值 NSKeyValueObservingOptionOld:change字典包括改变前的值 NSKeyValueObservingOptionInitial:注册后立刻触发KVO通知 NSKeyValueObservingOptionPrior:值改变前是否也要通知（这个key决定了是否在改变前改变后通知两次）</span><br><span class="line">    */</span><br><span class="line">    //创建Label目的是为了显示文字</span><br><span class="line">    myLabel = [[UILabel alloc]initWithFrame:CGRectMake(100, 100, 100, 30 )];</span><br><span class="line">    myLabel.textColor = [UIColor redColor];</span><br><span class="line">    myLabel.text = [stockForKVO valueForKey:@<span class="string">&quot;price&quot;</span>];</span><br><span class="line">    [self.view addSubview:myLabel];</span><br><span class="line">   </span><br><span class="line">    //创建Button, 在点击事件中改变Model的属性值</span><br><span class="line">    UIButton * b = [UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    b.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line">    [b addTarget:self action:@selector(buttonAction) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:b];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户单击View中的button调用控制器中的action去更改模型中的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void) buttonAction</span><br><span class="line">&#123;</span><br><span class="line">    [stockForKVO setValue:@<span class="string">&quot;20.0&quot;</span> forKey:@<span class="string">&quot;price&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当被观察对象的值发生变化的时候, 就会立即出发该方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(<span class="built_in">id</span>)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">/*keyPath：被监听的keyPath , 用来区分不同的KVO监听。 object： 被观察修改后的对象（可以通过object获得修改后的值） change：保存信息改变的字典（可能有旧的值，新的值等） context：上下文，用来区分不同的KVO监听。*/</span><br><span class="line">    <span class="keyword">if</span>([keyPath isEqualToString:@<span class="string">&quot;price&quot;</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        myLabel.text = [stockForKVO valueForKey:@<span class="string">&quot;price&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图dealloc需要取消观察</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [super dealloc];</span><br><span class="line">    //一定不要忘记移除观察者</span><br><span class="line">    [stockForKVO removeObserver:self forKeyPath:@<span class="string">&quot;price&quot;</span>];</span><br><span class="line">    [stockForKVO release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>KVO需要注意的两点:</strong></p><ol><li>KVO和Context: 由于Context通常用来区分不同的KVO，所以context的唯一性很重要。通常，我的使用方式是通过在当前.m文件里用静态变量定义。</li><li>KVO与线程: KVO的响应和KVO观察的值变化是在一个线程上的，所以，大多数时候，不要把KVO与多线程混合起来。除非能够保证所有的观察者都能线程安全的处理KVO</li></ol><h2 id="二-通知"><a href="#二-通知" class="headerlink" title="二, 通知"></a>二, 通知</h2><p>通知使用起来非常的简单, 按照以下三步操作即可：</p><ol><li><p>定义回调，即发生通知了我应该做啥事。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)callBack&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;收到通知我该干点啥呢?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册通知，即告诉通知中心，我对啥通知感兴趣</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver: self</span><br><span class="line">    selector: @selector(callBack)</span><br><span class="line">    name: @<span class="string">&quot;A类通知&quot;</span></span><br><span class="line">    object: nil];</span><br></pre></td></tr></table></figure></li><li><p>在程序任何一个地方都可以发送通知</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)getNotofocation&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;get it.&quot;</span>);</span><br><span class="line">    //发出通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@<span class="string">&quot;A类通知&quot;</span> object:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以在需要的时候取消注册通知。</p></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS观察者模式 </tag>
            
            <tag> KVO </tag>
            
            <tag> iOS通知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode7 无法请求到数据, iOS9无法请求HTTP类型的数据</title>
      <link href="/2015/10/13/xcode7-wu-fa-qing-qiu-dao-shu-ju-ios9-wu-fa-qing-qiu-http-lei-xing-de-shu-ju/"/>
      <url>/2015/10/13/xcode7-wu-fa-qing-qiu-dao-shu-ju-ios9-wu-fa-qing-qiu-http-lei-xing-de-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>在工程的info.plist文件中添加字段: </p><p><strong>NSAppTransportSecurity</strong>, 类型为 <strong>NSDictionary</strong>;</p><p>然后在此字段中添加 <strong>NSAllowsArbitraryLoads</strong> 字段, 类型为 <strong>Boolen</strong>, 设置置为 <strong>YES</strong> 即可!</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言关于补码的几个小知识</title>
      <link href="/2015/07/24/c-yu-yan-guan-yu-bu-ma-de-ji-ge-xiao-zhi-shi/"/>
      <url>/2015/07/24/c-yu-yan-guan-yu-bu-ma-de-ji-ge-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>​<br><strong>最重要的一点: 计算机存储的是补码, 其它什么码都是为了让补码容易理解才延伸出来的</strong></p><h2 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h2><p>计算机里面，只有加法器，没有减法器，所有的减法运算，都必须用加法进行。<br>即：减去某个数字（或者说加上某个负数）的运算，都应该研究如何用加法来完成。</p><h2 id="模、补数"><a href="#模、补数" class="headerlink" title="模、补数"></a>模、补数</h2><p>在日常生活当中，可以看到很多这样的事情：<br>把某物体左转 90 度，和右转 270 度，在不考虑圈数的条件下，最终的效果是相同的；<br>把分针倒拨 20 分钟，和正拨 40 分钟，在不考虑时针的条件下，效果也是相同的；<br>把数字 87，减去 25，和加上 75，在不考虑百位数的条件下，效果也是相同的；<br>……。<br>上述几组数字，有这样的关系：<br>　　90 + 270 &#x3D; 360<br>　　20 + 40 &#x3D; 60<br>　　25 + 75 &#x3D; 100<br>式中的 360、60 和 100，就是“模”（也可以理解成“进制”）。<br>式中的 90 和 270、20 和 40，以及 25 和 75，就是一对对“互补”的数字。</p><p>知道了“模”，求某个数字的“补数”，就是轻而易举的了：<br>如果模为 365，数字 120 的补数为：365 - 120 &#x3D; 245。</p><p><strong>用补数代替原数，可把减法转变为加法。出现的进位就是模，此时的进位，就应该忽略不计。</strong></p><h2 id="二进制数的模"><a href="#二进制数的模" class="headerlink" title="二进制数的模"></a>二进制数的模</h2><p>前面说过的十进制数 25 和 75，它们是 2 位数的运算，模是 100，即 1 的后面加上 2 个 0。<br>如果有 3 位数参加运算，模就是 1000，即 1 的后面加上 3 个 0。<br>这里的 1000，是十进制数的一千，可以写成 10^3，即 10 的 3 次方。<br>推论：有多少位数参加运算，模就是在 1 的后面加上多少个 0。</p><p>对于二进制数字，模也是这样推算。<br>如果是 3 位二进制数参加运算，模就是 1000，即 1 的后面加上 3 个 0；<br>那么当 8 位二进制数参加运算，模就是 1 0000 0000，即 1 的后面加上 8 个 0。<br>16 位二进制数参加运算，模可就大了，是 1 的后面加上 16 个 0。<br>注意：这里提到的 1、0，都是二进制数。<br>8 位二进制数的模可以按照十进制写成 2^8，即 256。<br>16 位数二进制数的模，就是 2^16，按照十进制，它就是 65536。</p><h2 id="二进制数的补码"><a href="#二进制数的补码" class="headerlink" title="二进制数的补码"></a>二进制数的补码</h2><p>求二进制数的补数，目的是往计算机里面存放。<br>在计算机里面，存放的数字什么的，都称为机器码；那么二进制形式的补数，也就改称为补码了。<br>一般情况下，都是以 8 位二进制数来讨论补码，少数也有用 16 位数的。</p><p>计算时加上正数，是不需要进行求取补数的；只有进行减法（或者加上负数），才需要对减数求补数。<br>**补码就是按照这个要求来定义的：正数不变，负数即用模减去绝对值。 **</p><p>已知一个数 X，其 8 位字长的补码定义为：</p><p>　　　　   (1)  X ;                 0 &lt;&#x3D; X &lt;&#x3D; +127 (正数和0的补码，就是该数字本身)<br>　　　　　(2)  2^8 －|X| ;    －128 &lt;&#x3D; X &lt; 0 (负数的补码，就是用 1 0000 0000（2的8次方），减去该数字的绝对值)</p><p>例如 X &#x3D; －126，其补码为 1000 0010，计算方法如下：</p><p>　　　　1 0000 0000<br>　　　－　0111  1110<br>　－－－－－－－－－－－<br>　　　　　1000 0010</p><p>可以看出，按照补码的定义来求补码，概念十分清晰，方法、步骤也是十分简单的。</p><h2 id="应用补码进行计算"><a href="#应用补码进行计算" class="headerlink" title="应用补码进行计算"></a>应用补码进行计算</h2><p>用补码计算：83－25＝58。</p><p>　　　　83　　－－－都变成补码，再用加法运算－－&gt;　   0101 0011<br>　　－　25　　－&gt; 1 0000 0000 - 0001 1001－&gt;   +            1110 0111<br>　－－－－－   　　　　　　　　                               －－－－－－－－<br>　　　　58　　&lt;－－忽略进位1，结果就是正确的－－[1]    0011 1010</p><p>（10-67） <br>  00001010 </p><p>+10111101 <br>&#x3D;11000111 取反加1后为00111001，既-57 <br>（21-16）<br>  00010101 <br>+11110000 <br>&#x3D;00000101 既为5 <br>（43-46） <br>  00101011 <br>+11010010 <br>&#x3D;11111101 取反加1后为00000011，既为-3</p><p>计算结果如果超出了－128～＋127的范围，结果将是错误的，这是没有办法纠正的。</p><p>应用补码进行计算，完全符合前面介绍的“用补数可把减法转换成加法”的做法，只要忽略进位（这个进位1，就是求补的时候，加进去的1 0000 0000中的1），结果就是正确的。</p><p>这些关于补数、补码的定义、方法、步骤，读者如果看懂了前面的文字，相信大家自己都可以总结出来。<br>那么为什么总有些网友要提出关于求取补码的问题呢？<br>在做而论道看来，就是因为很多教材和网文都在这个问题上“画蛇添足”。</p><h2 id="关于补码的蛇足"><a href="#关于补码的蛇足" class="headerlink" title="关于补码的蛇足"></a>关于补码的蛇足</h2><p>补码出现后，后人又补充了不少“蛇足”：符号位、求反加一、原码、反码……。<br>下面的表格给出了一些 8 位数的补码。</p><div class="gallery ">              <p><img src="/myImg/cyuyan.png" class="lazyload placeholder" data-srcset="/myImg/cyuyan.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="图片描述"></p>            </div><p>－－符号位<br>从这个表格中，可以看出特点：正数的最高位都是0，负数的最高位都是1。<br>这样一来，有人就把最高位理解成了符号位。说什么是规定的用0代表正号，……。并且郑重其事的补充说明：“符号位也参加运算”。真能忽悠！卖拐、卖车的都甘拜下风。<br>其实，前面说过的 补数 和 补码的定义式里面，根本就没有什么符号位 。这最高位的1、0是自然出现的，并不是由人来规定的。<br>－－求反加一<br>负数补码的后面七位，也可以看出一个不完全的规律：它们和绝对值之间存在着“求反加一”的关系。<br>于是，又有人推出了这个不同于定义式的算法。<br>－－原码和反码<br>由于使用“求反加一”来求取补码，顺便又引出了 原码 和 反码 两个垃圾概念。</p><p>其实，“求反加一”的计算方法只是适用于计算二进制形式的补数，它并不是通用的。<br>并且把“求反加一”用于求－128的补码，有个溢出的现象，很多人都在这里被弄瘸了很长时间。<br>原码和反码也只不过是“人工”进行“ 求反加一”时的中间过程，在计算机里面根本是不存在的，它们也就没有丝毫用处。</p><h2 id="座而论道的建议"><a href="#座而论道的建议" class="headerlink" title="座而论道的建议:"></a>座而论道的建议:</h2><p>求取补码，就按照定义的规定，负数采用“模减去绝对值”的方法来求，这是求补数的通用方法，适合于各种进制、各种大小的数字。<br>不要用求反加一的方法，也就不用理会原码和反码了，也不牵涉符号位的问题。<br>以后的计算，也就没有必要特殊说明：“符号位一起参加运算…”，因为根本就没有什么符号位。</p><p>如果把原码和反码、符号位等等垃圾概念，从计算机的书中删减掉，学习补码将会省力不少</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS验证邮箱, 手机号, 密码, 账户名 --- 正则表达式</title>
      <link href="/2015/07/07/ios-yan-zheng-you-xiang-shou-ji-hao-mi-ma-zhang-hu-ming-zheng-ze-biao-da-shi/"/>
      <url>/2015/07/07/ios-yan-zheng-you-xiang-shou-ji-hao-mi-ma-zhang-hu-ming-zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p>&#x2F;&#x2F;邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateEmail:(NSString *)email</span><br><span class="line">&#123;</span><br><span class="line">    NSString *emailRegex = @<span class="string">&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;</span>;</span><br><span class="line">    NSPredicate *emailTest = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>, emailRegex];</span><br><span class="line">    <span class="built_in">return</span> [emailTest evaluateWithObject:email];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;手机号码验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateMobile:(NSString *)mobile</span><br><span class="line">&#123;</span><br><span class="line">    //手机号以13， 15，18开头，八个 \d 数字字符</span><br><span class="line">    NSString *phoneRegex = @<span class="string">&quot;^((13[0-9])|(15[^4,\\D])|(18[0,0-9]))\\d&#123;8&#125;$&quot;</span>;</span><br><span class="line">    NSPredicate *phoneTest = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,phoneRegex];</span><br><span class="line">    <span class="built_in">return</span> [phoneTest evaluateWithObject:mobile];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;车牌号验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateCarNo:(NSString *)carNo</span><br><span class="line">&#123;</span><br><span class="line">    NSString *carRegex = @<span class="string">&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-zA-Z]&#123;1&#125;[a-zA-Z_0-9]&#123;4&#125;[a-zA-Z_0-9_\u4e00-\u9fa5]$&quot;</span>;</span><br><span class="line">    NSPredicate *carTest = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,carRegex];</span><br><span class="line">    NSLog(@<span class="string">&quot;carTest is %@&quot;</span>,carTest);</span><br><span class="line">    <span class="built_in">return</span> [carTest evaluateWithObject:carNo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;车型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateCarType:(NSString *)CarType</span><br><span class="line">&#123;</span><br><span class="line">    NSString *CarTypeRegex = @<span class="string">&quot;^[\u4E00-\u9FFF]+$&quot;</span>;</span><br><span class="line">    NSPredicate *carTest = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,CarTypeRegex];</span><br><span class="line">    <span class="built_in">return</span> [carTest evaluateWithObject:CarType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;昵称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateNickname:(NSString *)nickname</span><br><span class="line">&#123;</span><br><span class="line">    NSString *nicknameRegex = @<span class="string">&quot;^[\u4e00-\u9fa5]&#123;4,8&#125;$&quot;</span>;</span><br><span class="line">    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,nicknameRegex];</span><br><span class="line">    <span class="built_in">return</span> [passWordPredicate evaluateWithObject:nickname];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;身份证号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateIdentityCard: (NSString *)identityCard</span><br><span class="line">&#123;</span><br><span class="line">    BOOL flag;</span><br><span class="line">    <span class="keyword">if</span> (identityCard.length &lt;= 0) &#123;</span><br><span class="line">        flag = NO;</span><br><span class="line">        <span class="built_in">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *regex2 = @<span class="string">&quot;^(\\d&#123;14&#125;|\\d&#123;17&#125;)(\\d|[xX])$&quot;</span>;</span><br><span class="line">    NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,regex2];</span><br><span class="line">    <span class="built_in">return</span> [identityCardPredicate evaluateWithObject:identityCard];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;用户名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validateUserName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    NSString *userNameRegex = @<span class="string">&quot;^[A-Za-z0-9]&#123;6,20&#125;+$&quot;</span>;</span><br><span class="line">    NSPredicate *userNamePredicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,userNameRegex];</span><br><span class="line">    BOOL B = [userNamePredicate evaluateWithObject:name];</span><br><span class="line">    <span class="built_in">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL) validatePassword:(NSString *)passWord</span><br><span class="line">&#123;</span><br><span class="line">    NSString *passWordRegex = @<span class="string">&quot;^[a-zA-Z0-9]&#123;6,20&#125;+$&quot;</span>;</span><br><span class="line">    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@<span class="string">&quot;SELF MATCHES %@&quot;</span>,passWordRegex];</span><br><span class="line">    <span class="built_in">return</span> [passWordPredicate evaluateWithObject:passWord];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
